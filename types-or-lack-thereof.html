<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="keywords" content="Erlang, typing, dynamic, static, dialyzer, typer, strong typed, success types, reliability" />
		<meta name="description" content="Erlang's type system (or lack thereof): Dynamic strong typing, A proof of reliability without static type systems, type guards and conversions, and static type inference for Erlang" />
        <meta name="google-site-verification" content="mi1UCmFD_2pMLt2jsYHzi_0b6Go9xja8TGllOSoQPVU" />
		<link rel="stylesheet" type="text/css" href="static/css/screen.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shCore.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shThemeLYSE2.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/print.css" media="print" />
		<link href="rss" type="application/rss+xml" rel="alternate" title="LYSE news" />
		<link rel="icon" type="image/png" href="favicon.ico" />
		<link rel="apple-touch-icon" href="static/img/touch-icon-iphone.png" />
		<link rel="apple-touch-icon" sizes="72x72" href="static/img/touch-icon-ipad.png" />
		<link rel="apple-touch-icon" sizes="114x114" href="static/img/touch-icon-iphone4.png" />
		<title>Types (or lack thereof) | Learn You Some Erlang for Great Good!</title>
	</head>
	<body>
		<div id="wrapper">
			<div id="header">
				<h1>Learn you some Erlang</h1>
				<span>for great good!</span>
			</div> <!-- header -->
			<div id="menu">
				<ul>
					<li><a href="content.html" title="Home">Home</a></li>
					<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
					<li><a href="rss" title="Latest News">RSS</a></li>
					<li><a href="static/erlang/learn-you-some-erlang.zip" title="Source Code">Code</a></li>
				</ul>
			</div><!-- menu -->
			<div id="content">
            <div class="noscript"><noscript>Hey there, it appears your Javascript is disabled. That's fine, the site works without it. However, you might prefer reading it with syntax highlighting, which requires Javascript!</noscript></div>
<h2>类型（或者说缺少的参考）</h2>

<h3><a class="section" name="dynamite-strong-typing">强类型</a></h3>

<p>
	你也许已经注意到了当你在输入
	<a class="local chapter" href="starting-out-for-real.html" title="Starting Out (for real)">真正的开始</a>这章的例子时,
	还有<a class="local chapter" href="modules.html" title="Modules">模块</a>和
	<a class="chapter local" href="syntax-in-functions.html" title="Syntax in Functions">函数中的语法</a>中的例子时,
	我们从来没有被要求声明一个函数或变量的类型。
	当使用模式匹配的时候，我们所写的代码也不知道它将匹配到什么类型。
	元组<code>{<var>X</var>,<var>Y</var>}</code>可以匹配<code>{atom, 123}</code>同样也可以匹配 <code>{"A string", &lt;&lt;"binary stuff!"&gt;&gt;}</code>,
	<code>{2.0, ["strings","and",atoms]}</code>或者其它的任何东西。</p>

<p>当它不能工作时，错误信息会直接显示出来，但是这只会发生在你执行代码的时候。
	这是因为Erlang时<em>动态类型</em>：
	每个运行期发生的错误，编译器在编译模块的时候并不会告诉你，就像
	<a class="chapter local" href="starting-out-for-real.html#bool-and-compare" title="Boolean Algebra &amp; Comparison Operators">真正的开始</a>中<code>"llama + 5"</code>的例子。</p>

<img class="right" src="static/img/ham.png" width="388" height="246" alt="A knife slicing ham." title="I'll let you decide which is static and which is dynamic" />

<p>在动态和静态类型的支持者之间经常发生的争论是使用那种类型系统编写软件更安全。
	一个经常被提出来的想法是，一个具有完善的静态类型系统的编译器，可以在你执行代码之前就会检查出非常多的问题。
	因此，静态类型语言被认为比动态类型语言更安全。
	和很多动态语言比较这也许是真的，但是Erlang却不敢苟同，当然Erlang有记录在案的记录可以证明这一点。
	最好的例子是具有超过一百万行Erlang代码的<a class="external" href="http://www.erlang.se/publications/Ulf_Wiger.pdf" title="Ulf Wiger - Four-fold Increase in Productivity and Quality">Ericsson AXD 301 ATM switches</a>,
	通常该系统被报告具有<em>9个9</em>（99.9999999%）的高可用性。
	请注意，这并不表示，Erlang为基础的系统的中组件不是没有故障的，
	但是一个交换机包括计划停机的情况下达到99.9999999%可用是非常不错的。
	这部分原因是，Erlang的设计理念是，一旦一个组件出现故障，它不应当影响整个系统。
	这些错误可能赖在，编程错误，硬件异常或网络失效：
	而Erlang语言，包含的很多特性可以让你的程序分布式部署到不同的节点上，处理不可以预知的错误，和<em>永不</em>停机。
</p>

<p>
	简而言之，绝大部分语言和类型系统的目标是减少程序的错误，Erlang采取的策略是Erlang假设任何时候任何地方都会发生错误,
	并且Erlang确保覆盖所有的情况：Erlang的动态类型并不是程序的可靠性和安全行的障碍。
	这听起来像在做预言一样，但是我们将在后面的章节看到我们怎么做。</p>

<div class="note">
    <p><strong>注意：</strong>
		选择动态类型是因为一个简单的原因；
		最开始的时候，实现Erlang的人是使用动态类型的语言，
		因此，Erlang使用动态类型是非常自然的选择。</p>
</div>

<p>同时Erlang是一个非常抢类型的语言。一个弱类型的语言会在类型之间做自动的转换。
	如果Erlang是弱类型语言，我们将在看到<code>6 = 5 + "1".</code>这种代码，但是我们在实践当中
	会得到一个错误参数的异常：</p>

<pre class="brush:eshell">
1&gt; 6 + "1".
** exception error: bad argument in an arithmetic expression
     in operator  +/2
        called as 6 + "1"
</pre>

<p>
	当然，再非常多的时候，我们想将一个类型的数据转换成另一个类型的数据：
	将常规字符串变成二进制字符串去存储，或者将整形转化成浮点型。
	Erlang的标准库，提供了一系列函数来完成这件事情。</p>


<h3><a class="section" name="type-conversions">类型转换</a></h3>

<p>Erlang，像其它很多语言一样，可以通过转换来改变一个数据的类型。
	通常这些都是通过Erlang的内置函数来完成的，但是很多类型转换Erlang自身并没有实现。
	这类函数通常使用&lt;type&gt;_to_&lt;type&gt;这种格式，并且它们都是在<code>erlang</code>这个模块内实现的。
	下面是一些例子：</p>

<pre class="brush:eshell">
1&gt; erlang:list_to_integer("54").
54
2&gt; erlang:integer_to_list(54).
"54"
3&gt; erlang:list_to_integer("54.32").
** exception error: bad argument
     in function  list_to_integer/1
        called as list_to_integer("54.32")
4&gt; erlang:list_to_float("54.32").
54.32
5&gt; erlang:atom_to_list(true).
"true"
6&gt; erlang:list_to_bitstring("hi there").
&lt;&lt;"hi there"&gt;&gt;
7&gt; erlang:bitstring_to_list(&lt;&lt;"hi there"&gt;&gt;).
"hi there"
</pre>

<p>等等。我们正在进入一个语言中不优雅的地方：因为使用&lt;type&gt;_to_&lt;type&gt;这个模式，
	每次一个新的类型被添加到语言中的时候，一堆用来进行转换的BIF将会被添加！
	我们将现有的都列在了下面：</p>

<p><code>atom_to_binary/2, atom_to_list/1, binary_to_atom/2, binary_to_existing_atom/2, binary_to_list/1, bitstring_to_list/1, binary_to_term/1, float_to_list/1, fun_to_list/1, integer_to_list/1, integer_to_list/2, iolist_to_binary/1, iolist_to_atom/1, list_to_atom/1, list_to_binary/1, list_to_bitstring/1, list_to_existing_atom/1, list_to_float/1, list_to_integer/2, list_to_pid/1, list_to_tuple/1, pid_to_list/1, port_to_list/1, ref_to_list/1, term_to_binary/1, term_to_binary/2 and tuple_to_list/1.</code></p>

<p>这里有好多转换函数。
	我们将在本书中看到即便不是所有类型也是绝大部分，但实际上我们并不需要使用它们全部。</p>


<h3><a class="section" name="to-guard-a-data-type">数据类型哨位</a></h3>

<p>Erlang的基本数据类型非常容易通过视觉判断出来：
	元组使用大括号，列表使用中括号，字符串使用双引号，等等。
	对特定的数据类型我们可以使用模式匹配：
	<code>head/1</code>函数接受且只能接受列表当作参数，
	因为其它数据类型使用(<code>[H|_]</code>)这个模式匹配会失败。
</p>

<img class="left" src="static/img/my-name-is.png" width="146" height="79" alt="Hi, My name is Tuple" />

<p>即便这样，我们依然无法很好的处理数字类型的值，因为我们无法控制数值的范围。
	因此，我们在温度和判断驾驶年龄等函数中使用哨位。
	但是我们现在又碰到了另一个障碍。我们如何写一个匹配特定的数据类型模式哨位，去匹配想数字，原子或者字符串？
</p>

<p> 有些函数专门完成此类任务。
	这些函数将接受单个参数，如果参数类型是所需的则返回真，否则返回假。
	它们是名字为<em>类型检测BIF</em>且是可以在哨位条件表达式中使用的函数的一部分：/p>

<pre class="brush:eshell">
is_atom/1           is_binary/1         
is_bitstring/1      is_boolean/1        is_builtin/3        
is_float/1          is_function/1       is_function/2       
is_integer/1        is_list/1           is_number/1         
is_pid/1            is_port/1           is_record/2         
is_record/3         is_reference/1      is_tuple/1          
</pre>

<p> 只要是允许使用哨位表达式的地方，它们都可以像其它哨位表达式那样使用。
	你也许会想知道，为什么没有函数直接返回变量的数据类型（类似<code>type_of(X)&nbsp;-&gt; Type</code>）。
	这答案很简单。
	Erlang is about programming for the right cases: you only program for what you know will happen and what you expect.
	Everything else should cause errors as soon as possible. Although this might sound insane,
	the explanations you'll get in <a class="chapter" href="errors-and-exceptions.html">Errors and Exceptions</a>
	will hopefully make things clearer. Until then, just trust me on that.</p>

<div class="note">
    <p><strong>Note:</strong> type test BIFs constitute more than half of the functions allowed in guard expressions. The rest are also BIFs, but do not represent type tests. These are: <br />
<code>abs(Number), bit_size(Bitstring), byte_size(Bitstring), element(N, Tuple), float(Term), hd(List), length(List), node(), node(Pid|Ref|Port), round(Number), self(), size(Tuple|Bitstring), tl(List), trunc(Number), tuple_size(Tuple).</code></p>

    <p>The functions <code>node/1</code> and <code>self/0</code> are related to distributed Erlang and processes/actors. We'll eventually use them, but we've still got other topics to cover before then.</p>
</div>

<p>It may seem like Erlang data structures are relatively limited, but lists and tuples are usually enough to build other complex structures without worrying about anything. As an example the basic node of a binary tree could be represented as <code>{node, Value, Left, Right}</code>, where <var>Left</var> and <var>Right</var> are either similar nodes or empty tuples. I could also represent myself as:</p> 

<pre class="brush:erl">
{person, {name, &lt;&lt;"Fred T-H"&gt;&gt;},
         {qualities, ["handsome", "smart", "honest", "objective"]},
         {faults, ["liar"]},
         {skills, ["programming", "bass guitar", "underwater breakdancing"]}}.
</pre>

<p>Which shows that by nesting tuples and list and filling them with data, we can obtain complex data structures and build functions to operate on them.</p>
          
<div class="note update">
    <p><strong>Update:</strong><br />
    The release R13B04 saw the addition of the BIF <code>binary_to_term/2</code>, which lets you unserialize data the same way <code>binary_to_term/1</code> would, except the second argument is an option list. If you pass in <code>[safe]</code>, the binary won't be decoded if it contains unknown atoms or <a class="chapter local" href="higher-order-functions.html" title="Higher Order Functions chapter">anonymous functions</a>, which could exhaust memory.</p>
</div>

<h3><a class="section" name="for-type-junkies">For Type Junkies</a></h3>

<img class="right" src="static/img/type-dance.png" width="284" height="161" alt="A sign for homeless people: 'Will dance for types'" title="You know you would" />

<p>This section is meant to be read by programmers who can not live without a static type system for one reason or another. It will include a little bit more advanced theory and everything may not be understood by everyone. I will briefly describe tools used to do static type analysis in Erlang, defining custom types and getting more safety that way. These tools will be described for anyone to understand much later in the book, given that it is not necessary to use any of them to write reliable Erlang programs. Because we'll show them later, I'll give very little details about installing, running them, etc. Again, this section is for those who really can't live without advanced type systems.</p>

<p>Through the years, there were some attempts to build type systems on top of Erlang. One such attempt happened back in 1997, conducted by Simon Marlow, one of the lead developers of the Glasgow Haskell Compiler, and Philip Wadler, who worked on Haskell's design and has contributed to the theory behind monads (<a class="external" href="http://homepages.inf.ed.ac.uk/wadler/papers/erlang/erlang.pdf" title="A Practical Subtyping System for Erlang">Read the paper</a> on said type system). Joe Armstrong later <a class="external" href="http://webcem01.cem.itesm.mx:8005/erlang/cd/downloads/hopl_erlang.pdf" title="A history of Erlang">commented on the paper</a>:</p>

<blockquote title="Joe Armstrong - A History of Erlang">
    <p>One day Phil phoned me up and announced that a) Erlang needed a type system, b) he had written a small prototype of a type system and c) he had a one year’s sabbatical and was going to write a type system for Erlang and “were we interested?” Answer —“Yes.”</p>

    <p>Phil Wadler and Simon Marlow worked on a type system for over a year and the results were published in [20]. The results of the project were somewhat disappointing. To start with, only a subset of the language was type-checkable, the major omission being the lack of process types and of type checking inter-process messages.</p>
</blockquote>

<p>Processes and messages both being one of the core features of Erlang, it may explain why the system was never added to the language. Other attempts at typing Erlang failed. The efforts of the HiPE project (attempts to make Erlang's performances much better) produced Dialyzer, a static analysis tool still in use today, with its very own type inference mechanism.</p>

<p>The type system that came out of it is based on success typings, a concept different from Hindley-Milner or soft-typing type systems. Success types are simple in concept: the type-inference will not try to find the exact type of every expression, but it will guarantee that the types it infers are right, and that the type errors it finds are really errors.</p>

<p>The best example would come from the implementation of the function <code>and</code>, which will usually take two Boolean values and return 'true' if they're both true, 'false' otherwise. In Haskell's type system, this would be written <code>and :: bool -&gt; bool -&gt; bool</code>. If the <code>and</code> function had to be implemented in Erlang, it could be done the following way:</p>

<pre class="brush:erl">
and(false, _) -&gt; false;
and(_, false) -&gt; false;
and(true,true) -&gt; true.
</pre>

<p>Under success typing, the inferred type of the function would be <code>and(_,_) -&gt; bool()</code>, where <var>_</var> means 'anything'. The reason for this is simple: when running an Erlang program and calling this function with the arguments <code>false</code> and <code>42</code>, the result would still be 'false'. The use of the <code>_</code> wildcard in pattern matching made it that in practice, any argument can be passed as long as one of them is 'false' for the function to work. ML types would have thrown a fit (and its users had a heart attack) if you had called the function this way. Not Erlang. It might make more sense to you if you decide to read the paper on the <a class="external" href="http://www.it.uu.se/research/group/hipe/papers/succ_types.pdf" title="Tobias Lindahl &amp; Constantinos Sagonas - Practical Type Inference Based on Success Typings">implementation of success types</a>, which explains the rationale behind the behavior. I really encourage any type junkies out there to read it, it's an interesting and practical implementation definition.</p>

<p>The details about type definitions and function annotations are described in the Erlang Enhancement Proposal 8 (<a class="external" href="http://www.erlang.org/eeps/eep-0008.html" title="EEP 8">EEP 8</a>). If you're interested in using success typings in Erlang, check out the <a class="external" href="http://user.it.uu.se/~tobiasl/publications/typer.pdf" title="TypEr: A Type Annotator of Erlang Code">TypEr application</a> and Dialyzer, both part of the standard distribution. To use them, type in <code>$ typer --help</code> and <code>$ dialyzer --help</code> (<code>typer.exe --help</code> and <code>dialyzer.exe --help</code> for Windows, if they're accessible from the directory you are currently in).</p>

<p>TypEr will be used to generate type annotations for functions. Used on this small <a class="source" href="static/erlang/fifo.erl" title="A Queue module" >FIFO implementation</a>, it spits the following type annotations:</p>

<pre class="brush:erl">
%% File: fifo.erl
%% --------------
-spec new() -&gt; {'fifo',[],[]}.
-spec push({'fifo',_,_},_) -&gt; {'fifo',nonempty_maybe_improper_list(),_}.
-spec pop({'fifo',_,maybe_improper_list()}) -&gt; {_,{'fifo',_,_}}.
-spec empty({'fifo',_,_}) -&gt; bool().
</pre>

<img class="right explanation" src="static/img/fifo.png" width="237" height="162" alt="Implementation of fifo (queues): made out of two stacks (last-in first-out)." title="Implementation of fifo (queues): made out of two stacks (last-in first-out)." />

<p>Which is pretty much right. Improper lists should be avoided because <code>lists:reverse/1</code> doesn't support them, but someone bypassing the module's interface would be able to get through it and submit one. In this case, the functions <code>push/2</code> and <code>pop/2</code> might still succeed for a few calls before they cause an exception. This either tells us to add guards or refine our type definitions manually. Suppose we add the signature <code>-spec push({fifo,list(),list()},_)&nbsp;-&gt; {fifo,nonempty_list(),list()}.</code> and a function that passes an improper list to <code>push/2</code> to the module: when scanning it in Dialyzer (which checks and matches the types), the error message <samp>"The call fifo:push({fifo,[1|2],[]},3) breaks the contract '&lt;Type definition here&gt;'</samp> is output.</p>

<p>Dialyzer will complain only when code will break other code, and if it does, it'll usually be right (it will complain about more stuff too, like clauses that will never match or general discrepancies). Polymorphic data types are also possible to write and analyze with Dialyzer: the <code>hd()</code> function could be annotated with <code>-spec([A])&nbsp;-&gt; A.</code> and be analyzed correctly, although Erlang programmers seem to rarely use this type syntax.</p>

<div class="note koolaid">
	<p><strong>Don't drink too much Kool-Aid:</strong><br />
        Some of the things you can't expect Dialyzer and TypEr to do is type classes with constructors, first order types and recursive types. The types of Erlang are only annotations without effects or restrictions on actual compiling unless you enforce them yourself. The type checker will never tell you a program that can run right now (or has run for two years) has a type bug when it effectively causes no error when running (although you could have buggy code running correctly...)</p>

    <p>While recursive types are something that would be really interesting to have, they're unlikely to ever appear in the current forms of TypEr and Dialyzer (the paper above explains why). Defining your own types to simulate recursive types by adding one or two levels manually is the best you can do at the moment.</p>

    <p>It's certainly not a full-blown type system, not as strict or powerful as what languages like Scala, Haskell or Ocaml propose. Its warning and error messages are also usually a bit cryptic and not really user friendly. However, it's still a very good compromise if you really can't live in a dynamic world or wish for additional safety; just expect it to be a tool in your arsenal, not too much more.</p>
</div>

<div class="note update">
    <p><strong>Update:</strong><br />
       Since version R13B04, recursive types are now available as an experimental feature for Dialyzer. This makes the previous <em>Don't drink too much Kool-aid</em> partially wrong. Shame on me.</p>

    <p>Note that the <a class="docs" href="http://erlang.org/doc/reference_manual/typespec.html" title="Official Types and Functions Specifications spec">type documentation has also become official</a> (although it remains subject to change) and is more complete than what can be found in EEP8.</p>

</div>
				<ul class="navigation">
											<li><a href="syntax-in-functions.html" title="Previous chapter">&lt; Previous</a></li>
										
					<li><a href="contents.html" title="Index">Index</a></li>
					
											<li><a href="recursion.html" title="Next chapter">Next &gt;</a></li>
									</ul>
			</div><!-- content -->
			<div id="footer">
				<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License Details"><img src="static/img/cc.png" width="88" height="31" alt="Creative Commons Attribution Non-Commercial No Derivative License" /></a>
				<p>Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution Non-Commercial No Derivative License</p>
			</div> <!-- footer -->
		</div> <!-- wrapper -->
		<div id="grass" />
	<script type="text/javascript" src="static/js/shCore.js"></script>
	<script type="text/javascript" src="static/js/shBrushErlang2.js%3F11"></script>
	<script type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.all();
	</script>
	</body>
</html>
