<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="keywords" content="Erlang, modules, attributes, Compile, export, import, function, macro, syntax" />
		<meta name="description" content="Module syntax for Erlang: how to write basic functions, export and import them with module attributes, compile Erlang code for the VM, write macros, etc." />
        <meta name="google-site-verification" content="mi1UCmFD_2pMLt2jsYHzi_0b6Go9xja8TGllOSoQPVU" />
		<link rel="stylesheet" type="text/css" href="static/css/screen.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shCore.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shThemeLYSE2.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/print.css" media="print" />
		<link href="rss" type="application/rss+xml" rel="alternate" title="LYSE news" />
		<link rel="icon" type="image/png" href="favicon.ico" />
		<link rel="apple-touch-icon" href="static/img/touch-icon-iphone.png" />
		<link rel="apple-touch-icon" sizes="72x72" href="static/img/touch-icon-ipad.png" />
		<link rel="apple-touch-icon" sizes="114x114" href="static/img/touch-icon-iphone4.png" />
		<title>Modules | Learn You Some Erlang for Great Good!</title>
	</head>
	<body>
		<div id="wrapper">
			<div id="header">
				<h1>Learn you some Erlang</h1>
				<span>for great good!</span>
			</div> <!-- header -->
			<div id="menu">
				<ul>
					<li><a href="content.html" title="Home">Home</a></li>
					<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
					<li><a href="rss" title="Latest News">RSS</a></li>
					<li><a href="static/erlang/learn-you-some-erlang.zip" title="Source Code">Code</a></li>
				</ul>
			</div><!-- menu -->
			<div id="content">
            <div class="noscript"><noscript>Hey there, it appears your Javascript is disabled. That's fine, the site works without it. However, you might prefer reading it with syntax highlighting, which requires Javascript!</noscript></div>
<h2>Modules</h2>
<h3><a class="section" name="what-are-modules">什么是模块</a></h3>

<img class="left" src="static/img/modules.png" width="168" height="148" alt="A box with functions written on it" title="And yes, I do believe functions are squiggly little colorfoul lines stuffed in a cardboard box." />

<p>使用交互式的shell被认为是动态语言非常重要的一部分。通常对于测试各种代码是非常有用的。Erlang中绝大部分的基础数据类型都不需要编写一个文件来使用。
你可以丢掉键盘，出去打一天球，但是如果你在这停下来，你将是个非常差的Erlang程序员。代码需保存起来，以备将来使用！</p>

<p>这就是模块的作用。模块是将很多函数放到同一个命名空间，存储到一个文件中。
	另外，所有的函数都需要在模块中定义。你已经使用了模块，但是你没有察觉它。
	前面章节提到过BIF，像 <code>hd</code>和<code>tl</code>，实际上它们属于<code>erlang</code>这个模块，
	同样所有的数学，逻辑和布尔操作符都属于这个模块。
	和其它的函数不同的是，当你使用Erlang的时候，属于<code>erlang</code>这个模块会被自动引入。
	剩下的函数，你就需要用 <code>Module:Function(Arguments)</code>这种形式来调用了。
</p>

<p>你可以自己尝试下：</p>


<pre class="brush:eshell">
1&gt; erlang:element(2, {a,b,c}).
b
2&gt; element(2, {a,b,c}).
b
3&gt; lists:seq(1,4).
[1,2,3,4]
4&gt; seq(1,4).
** exception error: undefined shell command seq/2
</pre>


<p>List模块中的<code>seq</code>函数并没有被自动引入，但是<code>element</code>就被自动引入了。
	’undefined shell command‘这个错误是因为shell在查找像<code>f()</code>这样的shell命令，并且没有找到该命令的时候产生的。
	<code>erlang</code>模块中有些不常使用的函数，并不会自动引入。
</p>

<p>按道理来说，你应当将功能类似的函数放到一个模块中。
	列表相关的操作都被放到了<code>lists</code>模块中，关于IO的操作（输出到终端或写文件）都被放到了<code>io</code>模块中。
	你将遇到唯一一个不遵守前面提到的规则的模块是<code>erlang</code>模块，因为它包含了数学，转换，多进程和调整虚拟机相关的设置等。
	它们除了都是内置函数就没有其它的共同点了。
	你应当避免创建一个像<code>erlang</code>模块的模块并且要专注于清晰的逻辑分层。
</p>

<h3><a class="section" name="module-declaration">模块声明</a></h3>

<img class="right" src="static/img/declaration.png" width="95" height="139" alt="A scroll with small text on it" title="I HEREBY DECLARE THIS MODULE AS INDEPENDENT FROM THE OTHERS"/>

<p>当编写一个模块的时候，你能声明两种东西： <em>函数</em>和<em>属性</em>.
	属性是模块用来描述它自己的元数据，其中包括模块的名字，什么函数是对外可见的和代码编写者等。
	这种元数据是非常有用的，它能告诉编译器该如何编译同时它可以让人们从编译过的代码中得到有用信息而不需要去看代码。
</p>

<p>
	有大量的模块属性在全世界的Erlang代码中使用，事实上，你可以根据你的喜好定义你自己的属性。
	(There is a large variety of module attributes currently used in Erlang code across the world;
	as a matter of fact, you can even declare your own attributes for whatever you please.)
	这里有很多预先定义好的属性，在代码中，它们比别的属性更加常用。所有这些模块属性都使用这种写法<code>-Name(Attribute).</code>。
	为了让你的模块能编译，它们当中唯一必须的是：</p>

<dl>
	<dt>-module(Name).</dt>
	<dd>
		这始终是一个文件的第一个属性（和语句），因为一个很好的理由：
		它是这个模块的名字，并且这个<var>Name</var>是一个<a class="chapter" href="starting-out-for-real.html#atoms" title="atom definition">原子</a>。
		这个就是你用来从别的模块调用函数的名字。
		这种调用的写法是<code>M:F(A)</code>，其中<var>M</var>是模块名，<var>F</var>是函数，<var>A</var>是参数。
	</dd>
</dl>

<p>是时候让我们写一些代码了！我们第一个模块将会非常简单且无用。
	打开文本编辑器输入下面这些，然后把它们保存到<code>useless.erl</code>中：</p>

<pre class="brush:erl">
-module(useless).
</pre>

<p>
	这一行文本是一个有效的模块。
	真的！当然没有函数它很没用。让我们先决定什么函数从我们的‘useless’模块中导出。
	为了做这事情，我们将用另一个属性：
</p>

<dl>
	<dt>-export([Function1/Arity, Function2/Arity, ..., FunctionN/Arity]).</dt>
	<dd>
		这是用来定义该模块什么函数可以由外界被调用。
		它需要一个有元数的函数列表。(It takes a list of functions with their respective arity.)
		函数的元数是一个整数，代表有几个参数将传入函数。
		这个是非常重要的信息，因为在同一个模块中，我们可以定义同名但元数不同的函数。
		函数<code>add(X,Y)</code>和<code>add(X,Y,Z)</code>被认为是不同的，分别用<code>add/2</code>和<code>add/3</code>
		来表示。
	</dd>
</dl>

<div class="note">
	<p><strong>注意：</strong>
		导出的函数代表模块的接口。定义一个只导出必要函数的接口是非常重要的。(It is important to define an interface revealing strictly what is necessary for it to be used and nothing more.)
		这样做，可以让你随意优化其它的［隐藏的］实现细节，而不至于因为优化导致其它依赖你代码的模块不工作。
	</p>
</div>

<p>我们无用的模块将导出第一个有用的函数叫‘add’，它将接受2个参数。
	<code>-export</code>属性将被添加到模块的声名中：</p>

<pre class="brush:erl">
-export([add/2]).
</pre>

<p>接着，让我写这个函数：</p>

<pre class="brush:erl">
add(A,B) -&gt;
    A + B.
</pre>

<p>函数的语法是<code>Name(Args) -&gt; Body.</code>，其中<var>Name</var>是一个原子，
	<var>Body</var>是用逗号分割的多个Erlang表达式。函数以句号结束。Erlang并不使用‘return’关键字。
	‘Rerturn’是没用的！取而代之，函数的最后一个逻辑表达式所返回的值将会返回给调用者。
</p>

<p>
	添加下面的函数（为什么，因为每个教程都会有一个‘Hello world’的例子！即便在第四章！），
	并且不要忘记将它添加到<code>-export</code>属性中。
</p>

<pre class="brush:erl">
%% Shows greetings.
%% io:format/1 is the standard function used to output text.
hello() -&gt;
    io:format("Hello, world!~n").
</pre>

<p>我们从这个函数可以看到，注释单行是用<code>%</code>符号开头（使用<code>%%</code>完全是风格问题）。
	<code>hello/0</code>函数同样展示了怎么从外部模块调用模块内的函数。在这个场景,就像注释里面写的，
	<code>io:format/1</code>是一个标准的输出到文本的函数。
</p>

<p>最后一个添加到模块中的函数，使用了<code>add/2</code>和<code>hello/0</code>：</p>

<pre class="brush:erl">
greet_and_add_two(X) -&gt;
	hello(),
	add(X,2).
</pre>

<img class="left" src="static/img/imports.png" width="145" height="134" alt="A box being put in another one" title="Yes, I'm reusing drawings on that one" />

<p>
	不要忘记在导出列表中添加<code>greet_and_add_two/1</code>。
	因为是在同一个模块中声名的函数，所以对<code>hello/0</code>和<code>add/2</code>的调用，并不需要在前面添加模块的名称。
</p>

<p>
	你是受否想让调用<code>io:format/1</code>像调用<code>add/2</code>或其它这个某块中定义的函数一样，
	你可以在文件开头添加以下模块属性： <code>-import(io, [format/1]).</code>。
	然后你就可以直接调用<code>format("Hello, World!~n").</code>。
	更常见的，<code>-import</code>属性遵循以下原则：</p>

<pre class="brush:erl">
-import(Module, [Function1/Arity, ..., FunctionN/Arity]).
</pre>

<p>
	程序员在写代码的时候，导入函数并不比程序员的快捷方式强。
	(Importing a function is not much more than a shortcut for programmers when writing their code.)
	Erlang程序员非常不鼓励使用<code>-import</code>属性，因为有些人发现它降低了代码的可读性。
	在<code>io:format/2</code>和<code>io_lib:format/2</code>同时存在的情况下。
	为了找出使用了那个函数，就要到文件头去看那个模块被引入。
	所以，保留模块名被认为是更好的做法。通常，你会看到唯一引入的函数是从列表模块：
	列表模块中的函数比别的模块中的函数使用频率更高。
</p>

<p>你的<code><a class="source" href="static/erlang/useless.erl" title="final implementation">useless</a></code>模块将会看起来像下面的文件：</p>

<pre class="brush:erl">
-module(useless).
-export([add/2, hello/0, greet_and_add_two/1]).

add(A,B) -&gt;
    A + B.

%% Shows greetings.
%% io:format/1 is the standard function used to output text.
hello() -&gt;
    io:format("Hello, world!~n").

greet_and_add_two(X) -&gt;
    hello(),
    add(X,2).
</pre>

<p>We are done with the "useless" module.
	我们完成了"useless"模块。你现在可以将它保存到<code>useless.erl</code>里。
	‘.erl’是标准的Erlang代码扩展名，文件名应该定义在<code>-module</code>属性中的模块名，加上‘.erl’扩展名。
</p>

<p>Before showing how to compile the module and finally try all its exciting functions, we will see how to define and use macros. Erlang macros are really similar to C's '#define' statements, mainly used to define short functions and constants. They are simple expressions represented by text that will be replaced before the code is compiled for the VM. Such macros are mainly useful to avoid having magic values floating around your modules. A macro is defined as a module attribute of the form: <code>-define(MACRO, some_value).</code> and is used as <code>?MACRO</code> inside any function defined in the module. A 'function' macro could be written as <code>-define(sub(X,Y), X-Y).</code> and used like <code>?sub(23,47)</code>, later replaced by <code>23-47</code> by the compiler. Some people will use more complex macros, but the basic syntax stays the same.</p>


<h3><a class="section" name="compiling-the-code">Compiling the code</a></h3>

<p>Erlang code is compiled to bytecode in order to be used by the virtual machine. You can call the compiler from many places: <code>$ <a class="docs" href="http://erlang.org/doc/man/erlc.html" title="erlc manual">erlc</a> flags file.erl</code> when in the command line, <code>compile:file(FileName)</code> when in the shell or in a module, <code>c()</code> when in the shell, etc.</p>

<p>It's time to compile our useless module and try it. Open the Erlang shell, type in:</p>

<pre class="brush:eshell">
1&gt; cd("/path/to/where/you/saved/the-module/").
"Path Name to the directory you are in"
ok
</pre>

<p>By default, the shell will only look for files in the same directory it was started in and the standard library: <code>cd/1</code> is a function defined exclusively for the Erlang shell, telling it to change the directory to a new one so it's less annoying to browse for our files. Windows users should remember to use forward slashes. When this is done, do the following:</p>

<pre class="brush:eshell">
2&gt; c(useless).
{ok,useless}
</pre>

<p>If you have another message, make sure the file is named correctly, that you are in the right directory and that you've made no mistake in your <a class="source" href="static/erlang/useless.erl" title="check against THIS!">module</a>. Once you successfully compile code, you'll notice that a <code>useless.beam</code> file was added next to <code>useless.erl</code> in your directory. This is the compiled module. Let's try our first functions ever:</p>

<pre class="brush:eshell">
3&gt; useless:add(7,2).
9
4&gt; useless:hello().
Hello, world!
ok
5&gt; useless:greet_and_add_two(-3).
Hello, world!
-1
6&gt; useless:not_a_real_function().
** exception error: undefined function useless:not_a_real_function/0
</pre>

<p>The functions work as expected: <code>add/2</code> adds numbers, <code>hello/0</code> outputs "Hello, world!", and <code>greet_and_add_two/1</code> does both! Of course, you might be asking why <code>hello/0</code> returns the atom 'ok' after outputting text. This is because Erlang functions and expressions must <strong>always</strong> return something, even if they would not need to in other languages. As such, <code>io:format/1</code> returns 'ok' to denote a normal condition, the absence of errors.</p>

<p>Expression 6 shows an error being thrown because a function doesn't exist. If you have forgotten to export a function, this is the kind of error message you will have when trying it out.</p>

<div class="note">
	<p><strong>Note:</strong> If you were ever wondering, '.beam' stands for <em>Bogdan/Björn's Erlang Abstract Machine</em>, which is the VM itself. Other virtual machines for Erlang exist, but they're not really used anymore and are history: JAM (Joe's Abstract Machine, inspired by Prolog's <a class="external" href="http://en.wikipedia.org/wiki/Warren_Abstract_Machine" title="Warren Abstract Machin">WAM</a> and old BEAM, which attempted to compile Erlang to C, then to native code. Benchmarks demonstrated little benefits in this practice and the concept was given up.</p>
</div>

<p>There are a whole lot of compilation flags existing to get more control over how a module is compiled. You can get a list of all of them in the <a class="docs" href="http://erlang.org/doc/man/compile.html">Erlang documentation</a>. The most common flags are:</p>

<dl>
	<dt>-debug_info</dt>
	<dd>Erlang tools such as debuggers, code coverage and static analysis tools will use the debug information of a module in order to do their work.</dd>
	<dt>-{outdir,Dir}</dt>
	<dd>By default, the Erlang compiler will create the 'beam' files in the current directory. This will let you choose where to put the compiled file.</dd>
	<dt>-export_all</dt>
	<dd>Will ignore the <code>-export</code> module attribute and will instead export all functions defined. This is mainly useful when testing and developing new code, but should not be used in production.</dd>
	<dt>-{d,Macro} or {d,Macro,Value}</dt>
	<dd>Defines a macro to be used in the module, where <var>Macro</var> is an atom. This is more frequently used when dealing when unit-testing, ensuring that a module will only have its testing functions created and exported when they are explicitly wanted. By default, <var>Value</var> is 'true' if it's not defined as the third element of the tuple.</dd>
</dl>

<p>To compile our <code>useless</code> module with some flags, we could do one of the following:</p>

<pre class="brush:eshell">
7&gt; compile:file(useless, [debug_info, export_all]).
{ok,useless}
8&gt; c(useless, [debug_info, export_all]).
{ok,useless}
</pre>

<p>You can also be sneaky and define compile flags from within a module, with a module attribute. To get the same results as from expressions 7 and 8, the following line could be added to the module:</p>

<pre class="brush:erl">
-compile([debug_info, export_all]).
</pre>

<p>Then just compile and you'll get the same results as if you manually passed flags. Now that we're able to write down functions, compile them and execute them, it's time to see how far we can take them!</p>

<div class="note">
	<p><strong>Note:</strong> another option is to compile your Erlang module to native code. Native code compiling is <strong>not</strong> available for every platform and OS, but on those that support it, it can make your programs go faster (about 20% faster, based on anecdotal evidence). To compile to native code, you need to use the <code>hipe</code> module and call it the following way: <code>hipe:c(Module,OptionsList).</code> You could also use <code>c(Module,[native]).</code> when in the shell to achieve similar results. Note that the .beam file generated will contain both native and non-native code, and the native part will not be portable across platforms.</p>
</div>


<h3><a class="section" name="more-about-modules">More About Modules</a></h3>

<p>Before moving on to learning more about writing functions and barely useful snippets of code, there are a few other miscellaneous bits of information that might be useful to you in the future that I'd like to discuss.</p>

<p>The first one concerns metadata about modules. I mentioned in the beginning of this chapter that module attributes are metadata describing the module itself. Where can we find this metadata when we don't have an access to the source? Well the compiler plays nice with us: when compiling a module, it will pick up most module attributes and store them (along with other information) in a <code>module_info/0</code> function. You can see the metadata of the <code>useless</code> module the following way:</p>

<pre class="brush:eshell">
9&gt; useless:module_info().
[{exports,[{add,2},
           {hello,0},
           {greet_and_add_two,1},
           {module_info,0},
           {module_info,1}]},
 {imports,[]},
 {attributes,[{vsn,[174839656007867314473085021121413256129]}]},
 {compile,[{options,[]},
           {version,"4.6.2"},
           {time,{2009,9,9,22,15,50}},
           {source,"/home/ferd/learn-you-some-erlang/useless.erl"}]}]
10&gt; useless:module_info(attributes).
[{vsn,[174839656007867314473085021121413256129]}]
</pre>


<p>The snippet above also shows an additional function, <code>module_info/1</code> which will let you grab one specific piece of information. You can see exported functions, imported functions (none in this case!), attributes (this is where your custom metadata would go), and compile options and information. Had you decided to add <code>-author("An Erlang Champ").</code> to your module, it would have ended up in the same section as <code>vsn</code>. There are limited uses to module attributes when it comes to production stuff, but they can be nice when doing little tricks to help yourself out: I'm using them in my <a class="source" href="static/erlang/tester.erl" title="Automatic testing module. See warnings/0.">testing script</a> for this book to annotate functions for which unit tests could be better; the script looks up module attributes, finds the annotated functions and shows a warning about them.</p>

<div class="note">
    <p><strong>Note:</strong> <code>vsn</code> is an automatically generated unique value differentiating each version of your code, excluding comments. It is used in code hot-loading (upgrading an application while it runs, without stopping it) and by some tools related to release handling. You can also specify a <code>vsn</code> value yourself if you want: just add <code>-vsn(VersionNumber)</code> to your module.</p>
</div>

<img class="right explanation" src="static/img/circular-dependencies.png" width="237" height="255" alt="A small graph with three nodes: Mom, Dad and You. Mom and Dad are parents of You, and You is brother of Dad. Text under: 'If circular dependencies are digusting in real life, maybe they should be disgusting in your programs too'" title="Seems clear enough."/>

<p>Another point that would be nice to approach regards general module design: avoid circular dependencies! A module <var>A</var> should not call a module <var>B</var> that also calls module <var>A</var>. Such dependencies usually end up making code maintenance difficult. In fact, depending on too many modules even if they're not in a circular dependency can make maintenance harder. The last thing you want is to wake up in the middle of the night only to find a maniac software engineer or computer scientist trying to gouge your eyes out because of terrible code you have written.</p>

<p>For similar reasons (maintenance and fear for your eyes), it is usually considered a good practice to regroup functions that have similar roles close together. Starting and stopping an application or creating and deleting a record in some database are examples of such a scenario.</p>

<p>Well, that's enough for the pedantic moralizations. How about we explore Erlang a little more?</p>
				<ul class="navigation">
											<li><a href="starting-out-for-real.html" title="Previous chapter">&lt; Previous</a></li>
										
					<li><a href="contents.html" title="Index">Index</a></li>
					
											<li><a href="syntax-in-functions.html" title="Next chapter">Next &gt;</a></li>
									</ul>
			</div><!-- content -->
			<div id="footer">
				<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License Details"><img src="static/img/cc.png" width="88" height="31" alt="Creative Commons Attribution Non-Commercial No Derivative License" /></a>
				<p>Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution Non-Commercial No Derivative License</p>
			</div> <!-- footer -->
		</div> <!-- wrapper -->
		<div id="grass" />
	<script type="text/javascript" src="static/js/shCore.js"></script>
	<script type="text/javascript" src="static/js/shBrushErlang2.js%3F11"></script>
	<script type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.all();
	</script>
	</body>
</html>
