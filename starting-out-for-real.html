<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="keywords" content="Erlang, Numbers, Boolean algebra, Comparison, Pattern Matching, atoms, lists, tuples, bit syntax, comprehension" />
		<meta name="description" content="Erlang's basics explained: numbers, atoms, boolean algebra and comparison operators, tuples, lists, list comprehensions, bit syntax, pattern matching, etc." />
        <meta name="google-site-verification" content="mi1UCmFD_2pMLt2jsYHzi_0b6Go9xja8TGllOSoQPVU" />
		<link rel="stylesheet" type="text/css" href="static/css/screen.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shCore.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shThemeLYSE2.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/print.css" media="print" />
		<link href="rss" type="application/rss+xml" rel="alternate" title="LYSE news" />
		<link rel="icon" type="image/png" href="favicon.ico" />
		<link rel="apple-touch-icon" href="static/img/touch-icon-iphone.png" />
		<link rel="apple-touch-icon" sizes="72x72" href="static/img/touch-icon-ipad.png" />
		<link rel="apple-touch-icon" sizes="114x114" href="static/img/touch-icon-iphone4.png" />
		<title>Starting Out (for real) | Learn You Some Erlang for Great Good!</title>
	</head>
	<body>
		<div id="wrapper">
			<div id="header">
				<h1>Learn you some Erlang</h1>
				<span>for great good!</span>
			</div> <!-- header -->
			<div id="menu">
				<ul>
					<li><a href="content.html" title="Home">Home</a></li>
					<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
					<li><a href="rss" title="Latest News">RSS</a></li>
					<li><a href="static/erlang/learn-you-some-erlang.zip" title="Source Code">Code</a></li>
				</ul>
			</div><!-- menu -->
			<div id="content">
            <div class="noscript"><noscript>Hey there, it appears your Javascript is disabled. That's fine, the site works without it. However, you might prefer reading it with syntax highlighting, which requires Javascript!</noscript></div>
<h2>真正的尝试</h2>

<div class="note" style="margin-top:2.5em">
	<p>相对来说，Erlang是一个非常小巧且简单语言（就像C比C＋＋简单一样）。Erlang内置了几种基础类型，如本章将会介绍的绝大部分基础类型。
		强烈建议你的认真阅读，因为稍后的Erlang程序都会使用到本章内容。
		(Reading it is strongly advised as it explains the building blocks for all the programs you'll write with Erlang later on.)</p>
</div>

<h3><a class="section" name="numbers">数字</a></h3>

<p>Erlang的shell中 <strong>表达式必须使用句号结尾紧跟着是一个空白</strong>（换行，空格等），否则不会被执行。
	你可以使用逗号去隔开表达式，但是只有最后一行的结果会被显示出来（其余的语句也会被执行）。
	这种语法形式对很多人来说并不常见，这种语法是因为Erlang一开始是由一种逻辑式的语言Prolog实现的。
	(This is certainly unusual syntax for most people and it comes from the days Erlang was implemented directly in Prolog, a logic programming language.)</p>

<p>让我们像前一章所说的那样启动Erlang的shell，做一些小的尝试吧！</p>

<pre class="brush:eshell">
1&gt; 2 + 15.
17
2&gt; 49 * 100.
4900
3&gt; 1892 - 1472.
420
4&gt; 5 / 2.
2.5
5&gt; 5 div 2.
2
6&gt; 5 rem 2.
1
</pre>

<p>你可能已经发现了，Erlang并不关心你输入的是整型还是浮点型：在做算数处理的时候，这两种类型都是支持的。 <img class="right" src="static/img/calculator.png" width="97" height="128" alt="A calculator with the number '80085' typed in" title="tee hee" />
	Erlang算数操符支持自动类型转换的，只有整型和浮点型。
	(Integers and floating values are pretty much the only types of data Erlang's mathematical operators will handle transparently for you.)
	然而，如果你想整除的结果使用<code>div</code>，如果你想取余数使用<code>rem</code>（remainder）。</p>

<p>请注意，我们依然可以按照数学运算所服从的正常的优先级规则使用多个运算符。</p>

<pre class="brush:eshell">
7&gt; (50 * 100) - 4999.
1
8&gt; -(50 * 100 - 4999).
-1
9&gt; -50 * (100 - 4999).
244950
</pre>

<p>如果你想使用非10进制来表达整数，只需要使用这个模式<code>Base#Value</code> （Base的范围是2到36）：</p>

<pre class="brush:eshell">
10&gt; 2#101010.
42
11&gt; 8#0677.
447
12&gt; 16#AE.
174
</pre>

<p>不错吧！你现在拥有了一个语法怪异的桌面计算器！绝对酷！</p>


<h3><a class="section" name="invariable-variables">不变的变量</a></h3>

<p>虽然我们有了一个不错的计算器，但是到目前为止，我们还没有办法存储计算的结果。
	为此我们将使用变量。如果你读了本书的介绍，你就已经知道在函数式语言中，变量是不变的。
	变量的基本行为可以用这7个表达式来说明（请注意，变量首字母需要大写）：</p>

<pre class="brush:eshell">
1&gt; One.
* 1: variable 'One' is unbound
2&gt; One = 1.
1
3&gt; Un = Uno = One = 1.
1
4&gt; Two = One + One.
2
5&gt; Two = 2.        
2
6&gt; Two = Two + 1.
** exception error: no match of right hand side value 3
7&gt; two = 2.
** exception error: no match of right hand side value 2
</pre>

<p>第一，我们只能为变量赋值一次；
	第二，如果你给一个变量赋值时，该变量当前的值和所赋的值相同，你可以‘假装’给一个变量赋值。(then you can 'pretend' to assign a value to a variable if it's the same value it already has.)
	如果不同，Erlang将会报错的。
	虽然这很容易观察到，但是怎么解释比较负责，这完全取决于<code>=</code>的含义。
	<code>=</code>操作符（不是变量）扮演着比较值的角色，看符号的两端的值是否不同。
	如果两个值相同，它将返回进行比较的值：</p>

<pre class="brush:eshell">
8&gt; 47 = 45 + 2.
47
9&gt; 47 = 45 + 3.
** exception error: no match of right hand side value 48
</pre>

<p> 如果操作符左侧是未绑定值的变量（没有被赋值），Erlang会自动将右侧的值绑定到左侧的变量上（赋值操作）。(What this operator does when mixed with variables is that if the left-hand side term is a variable and it is unbound (has no value associated to it),
	Erlang will automatically bind the right-hand side value to the variable on the left-hand side.)
	比较操作会因此而成功，并且右值会被保存到变量中。
	(The comparison will consequently succeed and the variable will keep the value in memory.)</p>

<p><code>=</code>操作符的这种行为被称为’模式匹配‘,这是所有函数式语言都具备的，但是通常认为Erlang的实现更加完善和灵活。
	在本章中介绍列表和元组的环节，以及后面介绍函数的章节中，我们将学习更多关于模式匹配的知识。</p>

<p>另外这7个命令告诉我们变量是需要首字母大写的。第7个命令失败就是因为变量<var>two</var>首字母小写了。
	严格来说，变量也可以用下划线来开头（‘_’）， 但是根据惯例，以下划线开头的变量代表着你不关心它的值但是需要标注下这个变量是什么。
	(Technically, variables can start with an underscore ('_') too, but by convention their use is restricted to values you do not care about, yet you felt it was necessary to document what it contains.)</p>

<p>当然你可以单独使用一个下划线来做变量：</p>

<pre class="brush:eshell">
10&gt; _ = 14+3.
17
11&gt; _.
* 1: variable '_' is unbound
</pre>

<p>不像别的变量，只有一个下划线的变量是不会存储任何被赋的值。
	就现在而言，它一点用都没有，但是请谨记，因为某一个时刻你会用到它的。</p>

<div class="note">
	<p><strong>注意：</strong> 如果你在用shell做些尝试时，发现你给一个变量赋了一个错误的值，这个变量时可以被‘消除’的，用<code>f(Variable).</code>来消除。
		如果你想清理掉shell中所有的变量只要执行<code>f().</code>就可以了。</p>
	
	<p>当然这些函数只能在shell中使用。当你在编写项目的时候，你是无法通过这种方式来‘消除’变量的。
		之所以这么做，就是让你能在这种生产环境中使用：一个Erlang的shell已经执行了好多年都没有被中断过，在这期间，可以让我们多次的重复使用变量<var>X</var>。
		(Being able to do it only in the shell makes sense if you acknowledge Erlang being usable in industrial scenarios: it is wholly possible to have a shell being active for years without interruption... Let's bet that the variable <var>X</var> would be used more than once in that time period.)</p>
</div>


<h3><a class="section" name="atoms">Atoms</a></h3>


<p>There is a reason why variables names can't begin with a lowercase character: atoms. Atoms are literals, constants with their own name for value. What you see is what you get and don't expect more. The atom <var>cat</var> means "cat" and that's it. You can't play with it, you can't change it, you can't smash it to pieces; it's <var>cat</var>. Deal with it.</p>

<p>While single words starting with a lowercase letter is a way to write an atom, there's more than one manner to do it:</p>

<pre class="brush:eshell">
1&gt; atom.
atom
2&gt; atoms_rule.
atoms_rule
3&gt; atoms_rule@erlang.
atoms_rule@erlang
4&gt; 'Atoms can be cheated!'.
'Atoms can be cheated!'
5&gt; atom = 'atom'.
atom
</pre>

<p>An atom should be enclosed in single quotes (') if it does not begin with a lower-case letter or if it contains other characters than alphanumeric characters, underscore (_), or @.<br />
Expression 5 also shows that an atom with single quotes is exactly the same as a similar atom without them.</p>

<p>I compared atoms to constants having their name as their values. You may have worked with code that used constants before: as an example, let's say I have values for eye colors: <img class="left" src="static/img/atom.png" width="193" height="198" alt="An Atom, as imagined by Rutherford" /> <code>BLUE -&gt; 1, BROWN -&gt; 2, GREEN -&gt; 3, OTHER -&gt; 4</code>. You need to match the name of the constant to some underlying value. Atoms let you forget about the underlying values: my eye colors can simply be 'blue', 'brown', 'green' and 'other'. These colors can be used anywhere in any piece of code: the underlying values will never clash and it is impossible for such a constant to be undefined! If you really want constants with values associated to them, there's a way to do it that we'll see in <a class="chapter local" href="modules.html" title="Modules">chapter 4</a> (Modules).</p>

<p>An atom is therefore mainly useful to express or qualify data coupled with it. Used alone, it's a bit harder to find a good use to it. This is why we won't spend more time toying with them; their best use will come when coupled with other types of data.</p>

<div class="note koolaid">
	<p><strong>Don't drink too much Kool-Aid:</strong><br />
		Atoms are really nice and a great way to send messages or represent constants. However there are pitfalls to using atoms for too many things: an atom is referred to in an "atom table" which consumes memory (4 bytes/atom in a 32-bit system, 8 bytes/atom in a 64-bit system). The atom table is not garbage collected, and so atoms will accumulate until the system tips over, either from memory usage or because 1048577 atoms were declared.</p>

	<p>This means atoms should not be generated dynamically for whatever reason; if your system has to be reliable and user input lets someone crash it at will by telling it to create atoms, you're in serious trouble. Atoms should be seen as tools for the developer because honestly, it's what they are.</p>
</div>

<div class="note">
	<p><strong>Note:</strong> some atoms are reserved words and can not be used except for what the language designers wanted them to be: function names, operators, expressions, etc. These are:
		<code>after and andalso band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse query receive rem try when xor</code></p>
</div>

<img class="right" src="static/img/boole.png" width="198" height="224" alt="George Boole" title='"Sup baby, would you like to go Booling?"' />

<h3><a class="section" name="bool-and-compare">Boolean Algebra &amp; Comparison operators</a></h3>

<p>One would be in pretty deep trouble if one couldn't tell the difference between what's small and big, what's true and false. As any other language, Erlang has ways to let you use boolean operations and to compare items.</p>

<p>Boolean algebra is dirt simple:</p>

<pre class="brush:eshell">
1&gt; true and false.
false
2&gt; false or true.
true
3&gt; true xor false.
true
4&gt; not false.
true
5&gt; not (true and true).
false
</pre>

<div class="note">
	<p><strong>Note:</strong> the boolean operators <code>and</code> and <code>or</code> will always evaluate arguments on both sides of the operator. If you want to have the short-circuit operators (which will only evaluate the right-side argument if it needs to), use <code>andalso</code> and <code>orelse</code>.</p>
</div>

<p>Testing for equality or inequality is also dirt simple, but has slightly different symbols from those you see in many other languages:</p>

<pre class="brush:eshell">
6&gt; 5 =:= 5.
true
7&gt; 1 =:= 0.
false
8&gt; 1 =/= 0.
true
9&gt; 5 =:= 5.0. 
false
10&gt; 5 == 5.0.
true
11&gt; 5 /= 5.0.
false
</pre>

<p>First of all, if your usual language uses <code>==</code> and <code>!=</code> to test for and against equality, Erlang uses <code>=:=</code> and <code>=/=</code>.  The three last expressions (lines 9 to 11) also introduce us to a pitfall: Erlang won't care about floats and integers in arithmetic, but will do so when comparing them. No worry though, because the <code>==</code> and <code>/=</code> operators are there to help you in these cases. This is important to remember whether you want exact equality or not.</p>

<p>Other operators for comparisons are <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&gt;=</code> (greater than or equal to) and <code>=&lt;</code> (less than or equal to). That last one is backwards (in my opinion) and is the source of many syntax errors in my code. Keep an eye on that <code>=&lt;</code>.</p>

<pre class="brush:eshell">
12&gt; 1 &lt; 2.
true
13&gt; 1 &lt; 1.
false
14&gt; 1 &gt;= 1.
true
15&gt; 1 =&lt; 1.
true
</pre>

<p>What happens when doing <code>5 + llama</code> or <code>5 == true</code>? There's no better way to know than trying it and subsequently getting scared by error messages!</p>

<pre class="brush:eshell">
12&gt; 5 + llama.
** exception error: bad argument in an arithmetic expression
     in operator  +/2
        called as 5 + llama
</pre>

<p>Welp! Erlang doesn't really like you misusing some of its fundamental types! The emulator returns a nice error message here. It tells us it doesn't like one of the two arguments used around the <code>+</code> operator!</p>

<p>Erlang getting mad at you for wrong types is not always true though:</p>

<pre class="brush:eshell">
13&gt; 5 =:= true.
false
</pre>

<p>Why does it refuse different types in some operations but not others? While Erlang doesn't let you <em>add</em> anything with everything, it will let you <em>compare</em> them. This is because the creators of Erlang thought pragmaticism beats theory and decided it would be great to be able to simply write things like general sorting algorithms that could order any term. It's there to make your life simpler and can do so the vast majority of the time.</p>

<p>There is one last thing to keep in mind when doing boolean algebra and comparisons:</p>

<pre class="brush:eshell">
14&gt; 0 == false.
false
15&gt; 1 &lt; false.
true
</pre>

<p>Chances are you're pulling your hair if you come from procedural languages or most object-oriented languages. Line 14 should evaluate to <var>true</var> and line 15 to <var>false</var>! After all, false means 0 and true is anything else! Except in Erlang. Because I lied to you. Yes, I did that. Shame on me.</p>

<p>Erlang has no such things as boolean <var>true</var> and <var>false</var>. The terms true and false are atoms, but they are integrated well enough into the language you shouldn't have a problem with that as long as you don't expect false and true to mean anything but false and true.</p>

<div class="note">
	<p><strong>Note:</strong> The correct ordering of each element in a comparison is the following:<br />
	<code>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string</code></p>
	<p>You don't know all these types of things yet, but you will get to know them through the book. Just remember that this is why you can compare anything with anything! To quote Joe Armstrong, one of the creators of Erlang: "The actual order is not important - but that a total ordering is well defined is important."</p>
</div>


<h3><a class="section" name="tuples">Tuples</a></h3>

<p>A tuple is a way to organize data. It's a way to group together many terms when you know how many there are. In Erlang, a tuple is written in the form <code>{Element1, Element2, ..., ElementN}</code>. As an example, you'd give me the coordinates (x,y) if you wanted to tell me the position of a point in a Cartesian graph. We can represent this point as a tuple of two terms:</p>

<pre class="brush:eshell">
1&gt; X = 10, Y = 4.
4
2&gt; Point = {X,Y}.
{10,4}
</pre>

<p>In this case, a point will always be two terms. Instead of carrying the variables <var>X</var> and <var>Y</var> around the place, you only have to carry one instead. However, what can I do if I receive a point and only want the <var>X</var> coordinate? It's not hard to extract that information. Remember that when we assigned values, Erlang would never complain if they were the same. Let's exploit that! You may need to clean the variables we had set with <code>f()</code>.</p>

<pre class="brush:eshell">
3&gt; Point = {4,5}.
{4,5}
4&gt; {X,Y} = Point.
{4,5}
5&gt; X.
4
6&gt; {X,_} = Point.
{4,5}
</pre>

<p>From then on we can use <var>X</var> to get the first value of the tuple! How did that happen?  <img class="left" src="static/img/mr-brackets.png" width="178" height="178" alt="{Mr.Brackets}" />First, <var>X</var> and <var>Y</var> had no value and were thus considered unbound variables. When we set them in the tuple <var>{X,Y}</var> on the left-hand side of the <code>=</code> operator, the <code>=</code> operator compares both values: <var>{X,Y}</var> vs. <var>{4,5}</var>. Erlang is smart enough to unpack the values from the tuple and distribute them to the unbound variables on the left-hand side. Then the comparison is only <code>{4,5} = {4,5}</code>, which obviously succeeds! That's one of the many forms of pattern matching.</p>

<p>Note that on expression 6, I used the anonymous <var>_</var> variable. This is exactly how it's meant to be used: to drop the value that would usually be placed there since we won't use it. The <var>_</var> variable is always seen as unbound and acts as a wildcard for pattern matching. Pattern matching to unpack tuples will only work if the number of elements (the tuple's length) is the same.</p>

<pre class="brush:eshell">
7&gt; {_,_} = {4,5}.
{4,5}
8&gt; {_,_} = {4,5,6}.
** exception error: no match of right hand side value {4,5,6}
</pre>

<p>Tuples can also be useful when working with single values. How so? The simplest example is temperature:</p>

<pre class="brush:eshell">
9&gt; Temperature = 23.213.
23.213
</pre>

<p>Well, it sounds like a good day to go to the beach... Wait, is this temperature in Kelvin, Celsius or Fahrenheit?</p>

<pre class="brush:eshell">
10&gt; PreciseTemperature = {celsius, 23.213}.
{celsius,23.213}
11&gt; {kelvin, T} = PreciseTemperature.
** exception error: no match of right hand side value {celsius,23.213}
</pre>

<p>This throws an error, but it's exactly what we want! This is, again, pattern matching at work. The <code>=</code> operator ends up comparing <var>{kelvin, T}</var> and <var>{celsius, 23.213}</var>: even if the variable <var>T</var> is unbound, Erlang won't see the <var>celsius</var> atom as identical to the <var>kelvin</var> atom when comparing them. An exception is thrown which stops the execution of code. By doing so, the part of our program that expects a temperature in Kelvin won't be able to process temperatures sent in Celsius. This makes it easier for the programmer to know what is being sent around and also works as a debugging aid. A tuple which contains an atom with one element following it is called a 'tagged tuple'. Any element of a tuple can be of any type, even another tuple:</p>

<pre class="brush:eshell">
12&gt; {point, {X,Y}}.
{point,{4,5}}
</pre>

<p>What if we want to carry around more than one Point though?</p>


<h3><a class="section" name="lists">Lists!</a></h3>

<p>Lists are the bread and butter of many functional languages. They're used to solve all kinds of problems and are undoubtedly the most used data structure in Erlang. Lists can contain anything! Numbers, atoms, tuples, other lists; your wildest dreams in a single structure. The basic notation of a list is <code>[Element1, Element2, ..., ElementN]</code> and you can mix more than one type of data in it:</p>

<pre class="brush:eshell">
1&gt; [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
[1,2,3,{numbers,[4,5,6]},5.34,atom]
</pre>

<p>Simple enough, right?</p>

<pre class="brush:eshell">
2&gt; [97, 98, 99].
"abc"
</pre>

<p>Uh oh! This is one of the most disliked things in Erlang: strings! Strings are lists and the notation is absolutely the exact same! Why do people dislike it? Because of this:</p>

<pre class="brush:eshell">
3&gt; [97,98,99,4,5,6].
[97,98,99,4,5,6]
4&gt; [233].
"é"
</pre>

<p>Erlang will print lists of numbers as numbers only when at least one of them could not also represent a letter! There is no such thing as a real string in Erlang! This will no doubt come to haunt you in the future and you'll hate the language for it. Don't despair, because there are other ways to write strings we'll see later in this chapter.</p>

<div class="note koolaid">
	<p><strong>Don't drink too much Kool-Aid:</strong><br />
		This is why you may have heard Erlang is said to suck at string manipulation: there is no built-in string type like in most other languages. This is because of Erlang's origins as a language created and used by telecom companies. They never (or rarely) used strings and as such, never felt like adding them officially. However, most of Erlang's lack of sense in string manipulations is getting fixed with time: The VM now natively supports Unicode strings, and overall gets faster on string manipulations all the time.</p>
	<p>There is also a way to store strings as a binary data structure, making them really light and faster to work with. All in all, there are still some functions missing from the standard library and while string processing is definitely doable in Erlang, there are somewhat better languages for tasks that need lots of it, like Perl or Python.</p>
</div>

<p>To glue lists together, we use the <code>++</code> operator. The opposite of <code>++</code> is <code>--</code> and will remove elements from a list:</p>

<pre class="brush:eshell">
5&gt; [1,2,3] ++ [4,5].
[1,2,3,4,5]
6&gt; [1,2,3,4,5] -- [1,2,3].
[4,5]
7&gt; [2,4,2] -- [2,4].
[2]
8&gt; [2,4,2] -- [2,4,2].
[]
</pre>

<p>Both <code>++</code> and <code>--</code> are right-associative. This means the elements of many <code>--</code> or <code>++</code> operations will be done from right to left, as in the following examples:</p>

<pre class="brush:eshell">
9&gt; [1,2,3] -- [1,2] -- [3].
[3]
10&gt; [1,2,3] -- [1,2] -- [2].
[2,3]
</pre>

<p>Let's keep going. The first element of a list is named the Head, and the rest of the list is named the Tail. We will use two built-in functions (BIF) to get them.</p>

<pre class="brush:eshell">
11&gt; hd([1,2,3,4]).
1
12&gt; tl([1,2,3,4]).
[2,3,4]
</pre>

<div class="note">
	<p><strong>Note:</strong>  built-in functions (BIFs) are usually functions that could not be implemented in pure Erlang, and as such are defined in C, or whichever language Erlang happens to be implemented on (it was Prolog in the 80's). There are still some BIFs that could be done in Erlang but were still implemented in C in order to provide more speed to common operations. One example of this is the <code>length(List)</code> function, which will return the (you've guessed it) length of the list passed in as the argument.</p>
</div>

<p>Accessing or adding the head is fast and efficient: virtually all applications where you need to deal with lists will always operate on the head first. As it's used so frequently, there is a nicer way to separate the head from the tail of a list with the help of pattern matching: <code>[Head|Tail]</code>. Here's how you would add a new head to a list:</p>

<pre class="brush:eshell">
13&gt; List = [2,3,4].
[2,3,4]
14&gt; NewList = [1|List].
[1,2,3,4]
</pre>

<p>When processing lists, as you usually start with the head, you want a quick way to also store the tail to later operate on it. If you remember the way tuples work and how we used pattern matching to unpack the values of a point (<var>{X,Y}</var>), you'll know we can get the first element (the head) sliced off a list in a similar manner.</p>

<pre class="brush:eshell">
15&gt; [Head|Tail] = NewList.
[1,2,3,4]
16&gt; Head.
1
17&gt; Tail.
[2,3,4]
18&gt; [NewHead|NewTail] = Tail.
[2,3,4]
19&gt; NewHead.
2
</pre>

<p>The <code>|</code> we used is named the cons operator (constructor). In fact, any list can be built with only cons and values:</p>

<pre class="brush:eshell">
20&gt; [1 | []].
[1]
21&gt; [2 | [1 | []]].
[2,1]
22&gt; [3 | [2 | [1 | []] ] ].
[3,2,1]
</pre>

<p>This is to say any list can be built with the following formula: <code>[Term1| [Term2 | [... | [TermN]]]]...</code>. Lists can thus be defined recursively as a head preceding a tail, which is itself a head followed by more heads. In this sense we could imagine a list being a bit like an earthworm: you can slice it in half and you'll then have two worms.</p>

<img class="explanation" src="static/img/worm.png" width="288" height="331" alt="Two drawn worms, the first one normal with the text 'Head' and 'tail' as usual; the second has its head cut off, and under it a new 'head' is written." title="Worms, like lists can be defined recursively." />

<p>The ways Erlang lists can be built are sometimes confusing to people who are not used to similar constructors. To help you get familiar with the concept, read all of these examples (hint: they're all equivalent):</p>

<pre class="brush:eshell">
[a, b, c, d]
[a, b, c, d | []]
[a, b | [c, d]]
[a, b | [c | [d]]]
[a | [b | [c | [d]]]]
[a | [b | [c | [d | [] ]]]]
</pre>

<p>With this understood, you should be able to deal with list comprehensions.</p>

<div class="note">
	<p><strong>Note:</strong> Using the form <code>[1 | 2]</code> gives what we call an 'improper list'. Improper lists will work when you pattern match in the <code>[Head|Tail]</code> manner, but will fail to be used with standard functions of Erlang (even <code>length()</code>). This is because Erlang expects proper lists. Proper lists end with an empty list as their last cell. When declaring an item like <code>[2]</code>, the list is automatically formed in a proper manner. As such, <code>[1|[2]]</code> would work! Improper lists, although syntactically valid, are of very limited use outside of user-defined data structures.</p>
</div>


<h3><a class="section" name="list-comprehensions">List Comprehensions</a></h3>

<p>List comprehensions are ways to build or modify lists. They also make programs short and easy to understand compared to other ways of manipulating lists. It's based off the idea of set notation; if you've ever taken mathematics classes with set theory or if you've ever looked at mathematical notation, you probably know how that works. Set notation basically tells you how to build a set by specifying properties its members must satisfy. List comprehensions may be hard to grasp at first, but they're worth the effort. They make code cleaner and shorter, so don't hesitate to try and type in the examples until you understand them!</p>

<p>An example of set notation would be <img style="float:none; display:inline;" src="static/img/set-comprehension.png" alt="{x &isin; &real; x = x^2}" />.  That set notation tells you the results you want will be all real numbers who are equal to their own square. The result of that set would be <var>{0,1}</var>. Another set notation example, simpler and abbreviated would be <code>{x : x &gt; 0}</code>. Here, what we want is all numbers where <var>x</var> &gt; 0.</p>

<p>List comprehensions in Erlang are about building sets from other sets. Given the set <code>{2n : n in L}</code> where L is the list <var>[1,2,3,4]</var>, the Erlang implementation would be:</p>

<pre class="brush:eshell">
1&gt; [2*N || N &lt;- [1,2,3,4]].
[2,4,6,8]
</pre>

<p>Compare the mathematical notation to the Erlang one and there's not a lot that changes: brackets ({}) become square brackets ([]), the colon (:) becomes two pipes (||) and the word 'in' becomes the arrow (&lt;-). We only change symbols and keep the same logic.  In the example above, each value of <var>[1,2,3,4]</var> is sequentially pattern matched to <var>N</var>. The arrow acts exactly like the <code>=</code> operator, with the exception that it doesn't throw exceptions.</p>

<p>You can also add constraints to a list comprehension by using operations that return boolean values. if we wanted all the even numbers from one to ten, we could write something like:</p>

<pre class="brush:eshell">
2&gt; [X || X &lt;- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].
[2,4,6,8,10]
</pre>

<p>Where <code>X rem 2 =:= 0</code> checks if a number is even. Practical applications come when we decide we want to apply a function to each element of a list, forcing it to respect constraints, etc. As an example, say we own a restaurant. A customer enters, sees our menu and asks if he could have the prices of all the items costing between $3 and $10 with taxes (say 7%) counted in afterwards.</p>

<pre class="brush:eshell">
3&gt; RestaurantMenu = [{steak, 5.99}, {beer, 3.99}, {poutine, 3.50}, {kitten, 20.99}, {water, 0.00}].
[{steak,5.99},
 {beer,3.99},
 {poutine,3.5},
 {kitten,20.99},
 {water,0.0}]
4&gt; [{Item, Price*1.07} || {Item, Price} &lt;- RestaurantMenu, Price &gt;= 3, Price =&lt; 10].
[{steak,6.409300000000001},{beer,4.2693},{poutine,3.745}]
</pre>

<p>Of course, the decimals aren't rounded in a readable manner, but you get the point. The recipe for list comprehensions in Erlang is therefore <code>NewList = [Expression || Pattern &lt;- List, Condition1, Condition2, ... ConditionN]</code>. The part <code>Pattern &lt;- List</code> is named a Generator expression. You can have more than one!</p>

<pre class="brush:eshell">
5&gt; [X+Y || X &lt;- [1,2], Y &lt;- [2,3]].
[3,4,4,5]
</pre>

<p>This runs the operations <code>1+2</code>, <code>1+3</code>, <code>2+2</code>, <code>2+3</code>. So if you want to make the list comprehension recipe more generic, you get: <code>NewList = [Expression || GeneratorExp1, GeneratorExp2, ..., GeneratorExpN, Condition1, Condition2, ... ConditionM]</code>. Note that the generator expressions coupled with pattern matching also act as a filter:</p>

<pre class="brush:eshell">
6&gt; Weather = [{toronto, rain}, {montreal, storms}, {london, fog},   
6&gt;            {paris, sun}, {boston, fog}, {vancouver, snow}].
[{toronto,rain},
 {montreal,storms},
 {london,fog},
 {paris,sun},
 {boston,fog},
 {vancouver,snow}]
7&gt; FoggyPlaces = [X || {X, fog} &lt;- Weather].
[london,boston]
</pre>

<p>If an element of the list 'Weather' doesn't match the {X, fog} pattern, it's simply ignored in the list comprehension whereas the <code>=</code> operator would have thrown an exception.</p>

<p>There is one more basic data type left for us to see for now. It is a surprising feature that makes interpreting binary data easy as pie.</p>


<img class="right" src="static/img/binometer.png" width="211" height="132" alt="Speedometer with values in binary" />

<h3><a class="section" name="bit-syntax">Bit Syntax!</a></h3>

<p>Most languages have support for manipulating data such as numbers, atoms, tuples, lists, records and/or structs, etc. Most of them also only have very raw facilities to manipulate binary data. Erlang goes out of its way to provide useful abstractions when dealing with binary values with pattern matching taken to the next level. It makes dealing with raw binary data fun and easy (no, really), which was necessary for the telecom applications it was created to help with. Bit manipulation has a unique syntax and idioms that may look kind of weird at first, but if you know how bits and bytes generally work, this should make sense to you. <strong>You may want to skip the rest of this chapter otherwise</strong>.</p>

<p>Bit syntax encloses binary data between &lt;&lt; and &gt;&gt;, splits it in readable segments, and each segment is separated by a comma. A segment is a sequence of bits of a binary (not necessarily on a byte boundary, although this is the default behaviour). Say we want to store an orange pixel of true color (24 bits). If you've ever checked colors in Photoshop or in a CSS style sheet for the web, you know the hexadecimal notation has the format #RRGGBB.  A tint of orange is <var>#F09A29</var> in that notation, which could be expanded in Erlang to:</p>

<pre class="brush:eshell">
1&gt; Color = 16#F09A29.
15768105
2&gt; Pixel = &lt;&lt;Color:24&gt;&gt;.
&lt;&lt;240,154,41&gt;&gt;
</pre>

<p>This basically says "Put the binary values of <var>#F09A29</var> on 24 bits of space (Red on 8 bits, Green on 8 bits and Blue also on 8 bits) in the variable Pixel." The value can later be taken to be written to a file. This doesn't look like much, but once written to a file, what you'd get by opening it in a text editor would be a bunch of unreadable characters. When you read back from the file, Erlang would interpret the binary into the nice <var>&lt;&lt;240,151,41&gt;&gt;</var> format again!</p>

<p>What's more interesting is the ability to pattern match with binaries to unpack content:</p>

<pre class="brush:eshell">
3&gt; Pixels = &lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;.
&lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
4&gt; &lt;&lt;Pix1,Pix2,Pix3,Pix4&gt;&gt; = Pixels.
** exception error: no match of right hand side value &lt;&lt;213,45,132,64,76,32,76,
                                                        0,0,234,32,15&gt;&gt;
5&gt; &lt;&lt;Pix1:24, Pix2:24, Pix3:24, Pix4:24&gt;&gt; = Pixels.
&lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
</pre>

<p>What we did on command 3 is declare what would be precisely 4 pixels of RGB colors in binary.<br />
	On expression 4, we tried to unpack 4 values from the binary content. It throws an exception, because we have more than 4 segments, we in fact have 12! So what we do is tell Erlang that each variable on the left side will hold 24 bits of data. That's what <code>Var:24</code> means. We can then take the first pixel and unpack it further into single color values:</p>

<pre class="brush:eshell">
6&gt; &lt;&lt;R:8, G:8, B:8&gt;&gt; = &lt;&lt;Pix1:24&gt;&gt;.
&lt;&lt;213,45,132&gt;&gt;
7&gt; R.
213
</pre>

<p>"Yeah that's dandy. What if I only wanted the first color from the start though? will I have to unpack all these values all the time?" Hah! Doubt not! Erlang introduces more syntactic sugar and pattern matching to help you around:</p>

<pre class="brush:eshell">
8&gt; &lt;&lt;R:8, Rest/binary&gt;&gt; = Pixels.
&lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
9&gt; R.
213
</pre>

<p>Nice, huh? That's because Erlang accepts more than one way to describe a binary segment. Those are all valid:</p>
<pre class="expand">
	Value
	Value:Size
	Value/TypeSpecifierList
	Value:Size/TypeSpecifierList
</pre>

<p>where <var>Size</var> is going to represent bits or bytes (depending on <var>Type</var> and <var>Unit</var> below), and <var>TypeSpecifierList</var> represents one or more of the following:</p>

<dl>
	<dt>Type</dt>
	<dd>Possible values: <code>integer | float | binary | bytes | bitstring | bits | utf8 | utf16 | utf32</code></dd>
	<dd>This represents the kind of binary data used. Note that 'bytes' is shorthand for 'binary' and 'bits' is shorthand for 'bitstring'. When no type is specified, Erlang assumes an 'integer' type.</dd>
	<dt>Signedness</dt>
	<dd>Possible values: <code>signed | unsigned</code></dd>
	<dd>Only matters for matching when the type is integer. The default is 'unsigned'.</dd>
	<dt>Endianness</dt>
	<dd>Possible values: <code>big | little | native</code></dd>
	<dd>Endianness only matters when the Type is either integer, utf16, utf32, or float. This has to do with how the system reads binary data. As an example, the BMP image header format holds the size of its file as an integer stored on 4 bytes. For a file that has a size of 72 bytes, a little-endian system would represent this as <code>&lt;&lt;72,0,0,0&gt;&gt;</code> and a big-endian one as <code>&lt;&lt;0,0,0,72&gt;&gt;</code>. One will be read as '72' while the other will be read as '1207959552', so make sure you use the right endianness. There is also the option to use 'native', which will choose at run-time if the CPU uses little-endianness or big-endianness natively. By default, endianness is set to 'big'.</dd>
	<dt>Unit</dt>
	<dd>written <code>unit:Integer</code></dd>
	<dd>This is the size of each segment, in bits. The allowed range is 1..256 and is set by default to 1 for integers, floats and bit strings and to 8 for binary. The utf8, utf16 and utf32 types require no unit to be defined. The multiplication of Size by Unit is equal to the number of bits the segment will take and must be evenly divisible by 8. The unit size is usually used to ensure byte-alignment.</dd>
</dl>

<p>The TypeSpecifierList is built by separating attributes by a '-'.</p>

<p>Some examples may help digest the definitions:</p>

<pre class="brush:eshell">
10&gt; &lt;&lt;X1/unsigned&gt;&gt; =  &lt;&lt;-44&gt;&gt;.
&lt;&lt;"Ô"&gt;&gt;
11&gt; X1.
212
12&gt; &lt;&lt;X2/signed&gt;&gt; =  &lt;&lt;-44&gt;&gt;.  
&lt;&lt;"Ô"&gt;&gt;
13&gt; X2.
-44
14&gt; &lt;&lt;X2/integer-signed-little&gt;&gt; =  &lt;&lt;-44&gt;&gt;.
&lt;&lt;"Ô"&gt;&gt;
15&gt; X2.
-44
16&gt; &lt;&lt;N:8/unit:1&gt;&gt; = &lt;&lt;72&gt;&gt;.
&lt;&lt;"H"&gt;&gt;
17&gt; N.
72
18&gt; &lt;&lt;N/integer&gt;&gt; = &lt;&lt;72&gt;&gt;.
&lt;&lt;"H"&gt;&gt;
19&gt; &lt;&lt;Y:4/little-unit:8&gt;&gt; = &lt;&lt;72,0,0,0&gt;&gt;.      
&lt;&lt;72,0,0,0&gt;&gt;
20&gt; Y.
72
</pre>

<p>You can see there are more than one way to read, store and interpret binary data. This is a bit confusing, but still much simpler than using the usual tools given by most languages.</p>

<p>The standard binary operations (shifting bits to left and right, binary 'and', 'or', 'xor', or 'not') also exist in Erlang. Just use the functions <code>bsl</code> (Bit Shift Left), <code>bsr</code> (Bit Shift Right), <code>band</code>, <code>bor</code>, <code>bxor</code>, and <code>bnot</code>.</p>

<pre class="brush:eshell">
2#00100 = 2#00010 bsl 1.
2#00001 = 2#00010 bsr 1.
2#10101 = 2#10001 bor 2#00101.
</pre>

<p>With that kind of notation and the bit syntax in general, parsing and pattern matching binary data is a piece of cake. One could parse TCP segments with code like this:</p>

<pre class="brush:erl">
&lt;&lt;SourcePort:16, DestinationPort:16,
  AckNumber:32,
  DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,
  CheckSum: 16, UrgentPointer:16,
  Payload/binary&gt;&gt; = SomeBinary.
</pre>

<p>The same logic can then be applied to anything binary: video encoding, images, other protocol implementations, etc.</p>

<div class="note koolaid">
	<p><strong>Don't drink too much Kool-Aid:</strong><br />
		Erlang is slow compared to languages like C or C++. Unless you are a patient person, it would be a bad idea to do stuff like converting videos or images with it, even though the binary syntax makes it extremely interesting as I hinted above. Erlang is just not that great at heavy number crunching.</p>
	
	<p>Take note, however, that Erlang is still mighty fast for applications that do not require number crunching: reacting to events, message passing (with the help of atoms being extremely light), etc. It can deal with events in matters of milliseconds and as such is a great candidate for soft-real-time applications.</p>
</div>

<img class="right" src="static/img/string.png" width="38" height="142" alt="A string" />

<p>There's a whole other aspect to binary notation: bit strings. Binary strings are bolted on top of the language the same way they are with lists, but they're much more efficient in terms of space. This is because normal lists are linked lists (1 'node' per letter) while bit strings are more like C arrays. Bit strings use the syntax <code>&lt;&lt;"this is a bit string!"&gt;&gt;</code>. The downside of binary strings compared to lists is a loss in simplicity when it comes to pattern matching and manipulation. Consequently, people tend to use binary strings when storing text that won't be manipulated too much or when space efficiency is a real issue.</p>

<div class="note">
	<p><strong>Note:</strong> Even though bit strings are pretty light, you should avoid using them to tag values. It could be tempting to use string literals to say <code>{&lt;&lt;"temperature"&gt;&gt;,50}</code>, but always use atoms when doing that. Previously in this chapter, atoms were said to be taking only 4 or 8 bytes in space, no matter how long they are. By using them, you'll have basically no overhead when copying data from function to function or sending it to another Erlang node on another server. <br />
    Conversely, do not use atoms to replace strings because they are lighter. Strings can be manipulated (splitting, regular expressions, etc) while atoms can only be compared and nothing else.</p>
</div>


<h3><a class="section" name="binary-comprehensions">Binary Comprehensions</a></h3>

<p>Binary comprehensions are to bit syntax what list comprehensions are to lists: a way to make code short and concise. They are relatively new in the Erlang world as they were there in previous revisions of Erlang, but required a module implementing them to use a special compile flag in order to work. Since the R13B revisions (those used here), they've become standard and can be used anywhere, including the shell:</p>

<pre class="brush:eshell">
1&gt; [ X || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;1,2,3,4,5&gt;&gt;, X rem 2 == 0].     
[2,4]
</pre>

<p>The only change in syntax from regular list comprehensions is the <code>&lt;-</code> which became <code>&lt;=</code> and using binaries (&lt;&lt;&gt;&gt;) instead of lists ([]). Earlier in this chapter we've seen an example where there was a binary value of many pixels on which we used pattern matching to grab the RGB values of each pixel. It was alright, but on larger structures, it would become possibly harder to read and maintain. The same exercise can be done with a one-line binary comprehension, which is much cleaner:</p>

<pre class="brush:eshell">
2&gt; Pixels = &lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;.
&lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
3&gt; RGB = [ {R,G,B} || &lt;&lt;R:8,G:8,B:8&gt;&gt; &lt;= Pixels ].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
</pre>

<p>Changing <code>&lt;-</code> to <code>&lt;=</code> let us use a binary stream as a generator. The complete binary comprehension basically changed binary data to integers inside tuples. Another binary comprehension syntax exists to let you do the exact opposite:</p>

<pre class="brush:eshell">
4&gt; &lt;&lt; &lt;&lt;R:8, G:8, B:8&gt;&gt; ||  {R,G,B} &lt;- RGB &gt;&gt;.
&lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
</pre>

<p>Be careful, as the elements of the resulting binary require a clearly defined size if the generator returned binaries:</p>

<pre class="brush:eshell">
5&gt; &lt;&lt; &lt;&lt;Bin&gt;&gt; || Bin &lt;- [&lt;&lt;3,7,5,4,7&gt;&gt;] &gt;&gt;.
** exception error: bad argument
6&gt; &lt;&lt; &lt;&lt;Bin/binary&gt;&gt; || Bin &lt;- [&lt;&lt;3,7,5,4,7&gt;&gt;] &gt;&gt;.  
&lt;&lt;3,7,5,4,7&gt;&gt;
</pre>

<p>It's also possible to have a binary comprehension with a binary generator, given the fixed-size rule above is respected:</p>

<pre class="brush:eshell">
7&gt; &lt;&lt; &lt;&lt;(X+1)/integer&gt;&gt; || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;3,7,5,4,7&gt;&gt; &gt;&gt;.
&lt;&lt;4,8,6,5,8&gt;&gt;
</pre>

<div class="note">
	<p><strong>Note:</strong> At the time of this writing, binary comprehensions were seldom used and not documented very well. As such, it was decided not to dig more than what is necessary to identify them and understand their basic working. To understand more bit syntax as a whole, read the <a class="external" href="http://user.it.uu.se/~pergu/papers/erlang05.pdf" title="Bit-level Binaries and Generalized Comprehensions in Erlang">white paper defining their specification</a>.</p>
</div>
				<ul class="navigation">
											<li><a href="starting-out.html" title="Previous chapter">&lt; Previous</a></li>
										
					<li><a href="contents.html" title="Index">Index</a></li>
					
											<li><a href="modules.html" title="Next chapter">Next &gt;</a></li>
									</ul>
			</div><!-- content -->
			<div id="footer">
				<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License Details"><img src="static/img/cc.png" width="88" height="31" alt="Creative Commons Attribution Non-Commercial No Derivative License" /></a>
				<p>Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution Non-Commercial No Derivative License</p>
			</div> <!-- footer -->
		</div> <!-- wrapper -->
		<div id="grass" />
	<script type="text/javascript" src="static/js/shCore.js"></script>
	<script type="text/javascript" src="static/js/shBrushErlang2.js%3F11"></script>
	<script type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.all();
	</script>
	</body>
</html>
