<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="keywords" content="Erlang, function, recursion, tail, loop, stack, iterative, quicksort, factorial, list" />
		<meta name="description" content="Recursion: How to make recursive functions in Erlang, then replace them with tail recursive functions. Examples on how to do it, including a functional version of quicksort." />
        <meta name="google-site-verification" content="mi1UCmFD_2pMLt2jsYHzi_0b6Go9xja8TGllOSoQPVU" />
		<link rel="stylesheet" type="text/css" href="static/css/screen.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shCore.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shThemeLYSE2.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/print.css" media="print" />
		<link href="rss" type="application/rss+xml" rel="alternate" title="LYSE news" />
		<link rel="icon" type="image/png" href="favicon.ico" />
		<link rel="apple-touch-icon" href="static/img/touch-icon-iphone.png" />
		<link rel="apple-touch-icon" sizes="72x72" href="static/img/touch-icon-ipad.png" />
		<link rel="apple-touch-icon" sizes="114x114" href="static/img/touch-icon-iphone4.png" />
		<title>Recursion | Learn You Some Erlang for Great Good!</title>
	</head>
	<body>
		<div id="wrapper">
			<div id="header">
				<h1>Learn you some Erlang</h1>
				<span>for great good!</span>
			</div> <!-- header -->
			<div id="menu">
				<ul>
					<li><a href="content.html" title="Home">Home</a></li>
					<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
					<li><a href="rss" title="Latest News">RSS</a></li>
					<li><a href="static/erlang/learn-you-some-erlang.zip" title="Source Code">Code</a></li>
				</ul>
			</div><!-- menu -->
			<div id="content">
            <div class="noscript"><noscript>Hey there, it appears your Javascript is disabled. That's fine, the site works without it. However, you might prefer reading it with syntax highlighting, which requires Javascript!</noscript></div>
<h2>递归</h2>
<h3><a class="section" name="hello-recursion">你好 递归!</a></h3>

<img class="right" src="static/img/reCURSE.png" width="337" height="182" alt="A car on the road. Dialogue: 'Are we there yet? - No! - Are we there yet? - No! - Are we there yet? - reCURSE YOU KIDS!" title="I apologize for this terrible pun. No great idea could be found to illustrate recursion so you're stuck with this." />

<p> 那些熟悉命令式和面向对象编程语言的读者会想，我们到现在为止为什么还没有介绍循环体。
    对这个问题的回答是“什么是循环？”，在函数类编程语言中通常不提供<code>for</code>和<code>while</code>这种循环控制体。
    取而代之的，函数类编程语言使用<em>递归</em>这一概念。</p>

<p> 我想你还记得在入门那章中是如何介绍不变的变量。
    如果你不记得了，可以再 <a class="chapter" href="starting-out-for-real.html#invariable-variables" title="invariable variables, from Starting out (for real)">回顾</a>一下！
    递归同样可以记住数学概念和函数来解释。
    一个基本的数学函数，如值的阶乘解释递归函数的一个非常好的例子。
    一个数<var>n</var>的阶乘可以产生一个序列 <code>1 x 2 x 3 x ... x <var>n</var></code>，
    或反向的序列<code><var>n</var> x (<var>n</var>-1) x (<var>n</var>-2) x ... x 1</code>。
    我们举一个实例， 3的阶乘是<code>3! = 3 x 2 x 1 = 6</code>。
    4的阶乘将是 <code>4! = 4 x 3 x 2 x 1 = 24</code>。
    这样的函数可以被用下面的数语言来描述：</p>

<img src="static/img/fac.png" alt="n! = { 1 if n = 0 }, { n((n-1)!) if n &gt; 0 }" width="214" height="60" />

<p> 这个告诉我们，如果值<var>n</var>大于<samp>0</samp>时，我们将返回结果<samp>1</samp>。
    如果值大于0，我们将返回<var>n</var>乘以<code>n-1</code>的阶乘，直到n为1为止：
</p>

<pre class="expand">
4! = 4 x 3!
4! = 4 x 3 x 2!
4! = 4 x 3 x 2 x 1!
4! = 4 x 3 x 2 x 1 x 1
</pre>

<p>
    那我们如何将这些数学语言翻译为Erlang？
    这个过程非常简单。
    我们可以看下这些数学符号：
    <code>n!</code>,<samp>1</samp>和<code>n((n-1)!)</code>还有<code>if</code>。
    我们可以得到一个函数名(<code>n!</code>)，哨位(the <code>if</code>)和函数体(<samp>1</samp>和<code>n((n-1)!)</code>)。
    由于语法的限制的原因，我们将<code>n!</code>重命名为<code>fac(N)</code>：</p>

<pre class="brush:erl">
-module(recursive).
-export([fac/1]).

fac(N) when N == 0 -&gt; 1;
fac(N) when N &gt; 0  -&gt; N*fac(N-1).
</pre>

<p> 这个阶乘函数就算完成了！
    这个函数和数学定义非常相似。
    如果我们使用模式匹配，会让我们的函数定义更简单一些：</p>

<pre class="brush:erl">
fac(0) -&gt; 1;
fac(N) when N &gt; 0 -&gt; N*fac(N-1).
</pre>

<p> 所以对那些本身就是递归的数学定义，我们可以很容易且很快的翻译到Erlang中。
    并且我们处在循环中！简单的说递归，我们可以定义为“一个不断调用自己的函数”。
    因为我们无限的循环，我们需要一个终止条件（真正的术语叫<em>基本条件</em>）。
    在这个案例中，终止条件时当<var>n</var>等于<samp>0</samp>。
    此时此刻，我们可以停止调用函数自身且停止执行了。</p>


<h3><a class="section" name="length">长度函数</a></h3>

<p> 让我们在多做一些实践。
    我们将实现一个计算列表中元素数量的函数。
    所以在一开始我们就知道我应需要什么：</p>
<ul>
    <li>一个基本情况；</li>
    <li>一个调用自身的函数；</li>
    <li>一个用于测试我们函数的列表。</li>
</ul>

<p>
    写过很多递归函数后，我发现基本情况是最容易先写出来的：
    什么样的最简单的输入是我们最容易计算长度的？
    当然是空列表，因为它的长度为0。
    所以我们在处理长度的时候我们可以这样记下 <code>[] = 0</code>。
    剩下的最简单的情况是列表只有1个元素：<code>[_] = 1</code>。
    这听起来似乎足以让我们定义我们的基本情况。
    我们可以将这些加入我们的代码中：</p>

<pre class="brush:erl">
len([]) -&gt; 0;
len([_]) -&gt; 1.
</pre>

<p>
    非常好！我们可以计算列表的长度，给出的长度为0或1！这非常有用。
    当然，也没地方可以使用它，因为它还不是递归函数，下面将是比较复杂的部分了：
    扩展我们的函数，让它能递归，并计算超过长度超过1和0的列表。
    我们<a class="chapter local" href="starting-out-for-real.html#lists" title="Starting Out (for real): lists">早先提到的</a>
    列表是递归定义的<code>[1 | [2| ... [n | []]]]</code>。
    由于长度为1的列表我们可以定义为<code>[X|[]]</code>，长度为2的列表我们可以定义为<code>[X|[Y|[]]]</code>，
    我们就可以使用<code>[H|T]</code>这个模式匹配去匹配包含1个元素或多于1个元素的列表。
    请注意，第二个元素它本身也是个列表。
    这代表，我们只需要计算第一个元素然后用第二个元素做为参数调用自身。
    我们可以认为每个列表中的元素长度为1，那么我们可以将函数这样重写下：</p>

<pre class="brush:erl">
len([]) -&gt; 0;
len([_|T]) -&gt; 1 + len(T).
</pre>

<p>
    现在，我们得到了字节计算列表长度的递归函数。
    让我们看看<code>len/1</code>是如何执行的，我们用<code>[1,2,3,4]</code>这个列表来测试这个函数：</p>

<pre class="expand">
len([1,2,3,4]) = len([1 | [2,3,4])
               = 1 + len([2 | [3,4]])
               = 1 + 1 + len([3 | [4]])
               = 1 + 1 + 1 + len([4 | []])
               = 1 + 1 + 1 + 1 + len([])
               = 1 + 1 + 1 + 1 + 0
               = 1 + 1 + 1 + 1
               = 1 + 1 + 2
               = 1 + 3 
               = 4
</pre>

<p> 我们得到了一个正确的结果。
    恭喜你，你成功的写出了第一个可用的Erlang递归函数！</p>

<img class="right" src="static/img/tail-recursion.png" width="269" height="135" alt="A childish drawing of a pig with an arrow pointing to the tail mentionning 'tail recursion - Ferd, age 4'" />

<h3><a class="section" name="length-tail-recursion">尾递归长度函数</a></h3>

<p>你可能已经发现，包含4个元素的列表，我们将我们函数展开了10次。
    尽管这个在短列表上表现的非常豪，但是当一个列表包含数百万项时，这就成问题了。
    你当然不想为了这么简单的函数在内存中保存数百万的数字。
    这很浪费并且这还有一个更好的方式。让我们开始使用<em>尾递归</em></p>

<p>
    尾递归是一种变换上述线性过程（一个随着元素数量增多而增长的过程）到一个迭代过程（没有任何实际增长）。
    一个函数要成为尾递归函数，他需要‘无副作用’。
    让我来解释下吧：是什么让我们的以前的函数调用不断增长，是第一调用的结果依赖于第二次对函数的调用。
    要获得<code>1 + len(Rest)</code>的结果，就需要<code>len(Rest)</code>的结果。
    <code>len(Rest)</code>函数本身，还需要另一次函数调用的结果。
    这些都会用堆栈堆叠起来，直到只剩下最后一个元素并且只有最后一个元素的结果被计算出来才会结束。
    尾递归函数的目标就是为了消除这种堆栈的堆叠。</p>

<p> 为了达到这个目的，我们需要在我们的函数中增加一个额外的临时变量。
    我借助阶乘函数说明了递归函数的概念，但这次我们将它定义为尾递归。
    我刚刚描述的临时的变量很多时候被称为<em>累加器</em>,它起到了限制我们调用的增长的作用，
    同时为我们提供了结果存储的地方：</p>

<pre class="brush:erl">
tail_fac(N) -&gt; tail_fac(N,1).

tail_fac(0,Acc) -&gt; Acc;
tail_fac(N,Acc) when N &gt; 0 -&gt; tail_fac(N-1,N*Acc).
</pre>

<p>
    此处，我们定义了<code>tail_fac/1</code>和<code>tail_fac/2</code>.
    这样做的原因是，Erlang不允许函数中使用默认参数（不同的参数个数意味着不同的功能），但是我们可以人工这么做。
    在特殊的情况下，<code>tail_fac/1</code>可以充当尾递归函数<code>tail_fac/2</code>的抽象。
    <code>tail_fac/2</code>隐藏的累加器细节不会影响任何人，所以我们可以从我们的模块中只导出<code>tail_fac/1</code>。
    当执行这个函数，我们可以这样展开：</p>

<pre class="expand">
tail_fac(4)    = tail_fac(4,1)
tail_fac(4,1)  = tail_fac(4-1, 4*1)
tail_fac(3,4)  = tail_fac(3-1, 3*4)
tail_fac(2,12) = tail_fac(2-1, 2*12)
tail_fac(1,24) = tail_fac(1-1, 1*24)
tail_fac(0,24) = 24
</pre>

<p>
    我们可以看到不同？
    现在我们不会同时在内存中保存两个以上的变量：
    因此我们内存使用是固定的。
    即便计算1百万的阶乘和计算4的阶乘将会消耗相同的空间（在这个场景下，以至于我们忘记了4！是一个远小于1M!的数字）。
</p>

<p>
    看到你面前的这个尾递归阶乘函数的例子，你也许看到了怎么将这个模式应用在我们的<code>len/1</code>函数上。
    所有我们需要做的就是让我们的递归函数‘无副作用’。
    如果你想看例子，你可以想像通过添加一个参数将<code>+1</code>这段代码放在你的函数调用中：</p>

<pre class="brush:erl">
len([]) -&gt; 0;
len([_|T]) -&gt; 1 + len(T).
</pre>

<p>变成：</p>

<pre class="brush:erl">
tail_len(L) -&gt; tail_len(L,0).

tail_len([], Acc) -&gt; Acc;
tail_len([_|T], Acc) -&gt; tail_len(T,Acc+1).
</pre>

<p>现在你编写的长度函数就是尾递归的了。</p>


<h3><a class="section" name="more-recursive-functions">更多的尾递归函数</a></h3>

<img class="left" src="static/img/rock-paper-scissors.png" width="287" height="259" alt="A tiny planet with a rock running after paper running after a pair of scissors which runs after the rock itself." title="I'm stretching the concept too much here." />

<p>
    我们会在写几个这样的递归函数，让我们逐渐熟悉这个东西。
    毕竟，递归是Erlang中仅有的循环体（除了列表解构),所以它是必须要牢记的原则之一。
    这对你将来学习其它计算机语言也非常有用，所以请记住这个！</p>

<p>The first function we'll write will be <code>duplicate/2</code>. This function takes an integer as its first parameter and then any other term as its second parameter. It will then create a list of as many copies of the term as specified by the integer. Like before, thinking of the base case first is what might help you get going. For <code>duplicate/2</code>, asking to repeat something 0 time is the most basic thing that can be done. All we have to do is return an empty list, no matter what the term is. Every other case needs to try and get to the base case by calling the function itself. We will also forbid negative values for the integer, because you can't duplicate something <code>-n</code> times:</p>

<pre class="brush:erl">
duplicate(0,_) -&gt;
    [];
duplicate(N,Term) when N &gt; 0 -&gt;
    [Term|duplicate(N-1,Term)].
</pre>

<p>Once the basic recursive function is found, it becomes easier to transform it into a tail recursive one by moving the list construction into a temporary variable:</p>

<pre class="brush:erl">
tail_duplicate(N,Term) -&gt;
    tail_duplicate(N,Term,[]).

tail_duplicate(0,_,List) -&gt;
    List;
tail_duplicate(N,Term,List) when N &gt; 0 -&gt;
    tail_duplicate(N-1, Term, [Term|List]).
</pre>

<p>Success! I want to change the subject a little bit here by drawing a parallel between tail recursion and a while loop. Our <code>tail_duplicate/2</code> function has all the usual parts of a while loop. If we were to imagine a while loop in a fictional language with Erlang-like syntax, our function could look a bit like this:</p>

<pre class="brush:erl">
function(N, Term) -&gt;
    while N &gt; 0 -&gt;
        List = [Term|List],
        N = N-1
    end,
    List.
</pre>

<p>Note that all the elements are there in both the fictional language and in Erlang. Only their position changes. This demonstrates that a proper tail recursive function is similar to an iterative process, like a while loop.</p>

<p>There's also an interesting property that we can 'discover' when we compare recursive and tail recursive functions by writing a <code>reverse/1</code> function, which will reverse a list of terms. For such a function, the base case is an empty list, for which we have nothing to reverse. We can just return an empty list when that happens. Every other possibility should try to converge to the base case by calling itself, like with <code>duplicate/2</code>. Our function is going to iterate through the list by pattern matching <code>[H|T]</code> and then putting <var>H</var> after the rest of the list:</p>

<pre class="brush:erl">
reverse([]) -&gt; [];
reverse([H|T]) -&gt; reverse(T)++[H].
</pre>

<p>On long lists, this will be a true nightmare: not only will we stack up all our append operations, but we will need to traverse the whole list for every single of these appends until the last one! For visual readers, the many checks can be represented as:</p>

<pre class="expand">
reverse([1,2,3,4]) = [4]++[3]++[2]++[1]
                      &#8593;    &#8629;
                   = [4,3]++[2]++[1]
                      &#8593; &#8593;    &#8629;
                   = [4,3,2]++[1]
                      &#8593; &#8593; &#8593;    &#8629;
                   = [4,3,2,1]
</pre>

<p>This is where tail recursion comes to the rescue. Because we will use an accumulator and will add a new head to it every time, our list will automatically be reversed. Let's first see the implementation:</p>

<pre class="brush:erl">
tail_reverse(L) -&gt; tail_reverse(L,[]).

tail_reverse([],Acc) -&gt; Acc;
tail_reverse([H|T],Acc) -&gt; tail_reverse(T, [H|Acc]).
</pre>

<p>If we represent this one in a similar manner as the normal version, we get:</p>

<pre class="expand">
tail_reverse([1,2,3,4]) = tail_reverse([2,3,4], [1])
                        = tail_reverse([3,4], [2,1])
                        = tail_reverse([4], [3,2,1])
                        = tail_reverse([], [4,3,2,1])
                        = [4,3,2,1]   
</pre>

<p>Which shows that the number of elements visited to reverse our list is now linear: not only do we avoid growing the stack, we also do our operations in a much more efficient manner!</p>

<p>Another function to implement could be <code>sublist/2</code>, which takes a list <var>L</var> and an integer <var>N</var>, and returns the <var>N</var> first elements of the list. As an example, <code>sublist([1,2,3,4,5,6],3)</code> would return <samp>[1,2,3]</samp>. Again, the base case is trying to obtain 0 elements from a list. Take care however, because <code>sublist/2</code> is a bit different. You've got a second base case when the list passed is empty! If we do not check for empty lists, an error would be thrown when calling <code>recursive:sublist([1],2).</code> while we want <code>[1]</code> instead. Once this is defined, the recursive part of the function only has to cycle through the list, keeping elements as it goes, until it hits one of the base cases:</p>

<pre class="brush:erl">
sublist(_,0) -&gt; [];
sublist([],_) -&gt; [];
sublist([H|T],N) when N &gt; 0 -&gt; [H|sublist(T,N-1)].
</pre>

<p>Which can then be transformed to a tail recursive form in the same manner as before:</p>

<pre class="brush:erl">
tail_sublist(L, N) -&gt; tail_sublist(L, N, []).

tail_sublist(_, 0, SubList) -&gt; SubList;
tail_sublist([], _, SubList) -&gt; SubList;
tail_sublist([H|T], N, SubList) when N &gt; 0 -&gt;
    tail_sublist(T, N-1, [H|SubList]).
</pre>

<p>There's a flaw in this function. <em>A fatal flaw!</em> We use a list as an accumulator in exactly the same manner we did to reverse our list. If you compile this function as is, <code>sublist([1,2,3,4,5,6],3)</code> would not return <samp>[1,2,3]</samp>, but <samp>[3,2,1]</samp>. The only thing we can do is take the final result and reverse it ourselves. Just change the <code>tail_sublist/2</code> call and leave all our recursive logic intact:</p>

<pre class="brush:erl">
tail_sublist(L, N) -&gt; reverse(tail_sublist(L, N, [])).
</pre>

<p>The final result will be ordered correctly. It might seem like reversing our list after a tail recursive call is a waste of time and you would be partially right (we still save memory doing this). On shorter lists, you might find your code is running faster with normal recursive calls than with tail recursive calls for this reason, but as your data sets grow, reversing the list will be comparatively lighter.</p>

<div class="note">
    <p><strong>Note:</strong> instead of writing your own <code>reverse/1</code> function, you should use <code>lists:reverse/1</code>. It's been used so much for tail recursive calls that the maintainers and developers of Erlang decided to turn it into a BIF. Your lists can now benefit from extremely fast reversal (thanks to functions written in C) which will make the reversal disadvantage a lot less obvious. The rest of the code in this chapter will make use of our own reversal function, but after that you should not use it ever again.</p>
</div>

<p>To push things a bit further, we'll write a zipping function. A zipping function will take two lists of same length as parameters and will join them as a list of tuples which all hold two terms. Our own <code>zip/2</code> function will behave this way:</p>

<pre class="brush:eshell">
1&gt; recursive:zip([a,b,c],[1,2,3]).
[{a,1},{b,2},{c,3}]
</pre>

<p>Given we want our parameters to both have the same length, the base case will be zipping two empty lists:</p>

<pre class="brush:erl">
zip([],[]) -&gt; [];
zip([X|Xs],[Y|Ys]) -&gt; [{X,Y}|zip(Xs,Ys)].
</pre>

<p>However, if you wanted a more lenient zip function, you could decide to have it finish whenever one of the two list is done. In this scenario, you therefore have two base cases:</p>

<pre class="brush:erl">
lenient_zip([],_) -&gt; [];
lenient_zip(_,[]) -&gt; [];
lenient_zip([X|Xs],[Y|Ys]) -&gt; [{X,Y}|lenient_zip(Xs,Ys)].
</pre>


<p>Notice that no matter what our base cases are, the recursive part of the function remains the same. I would suggest you try and make your own tail recursive versions of <code>zip/2</code> and <code>lenient_zip/2</code>, just to make sure you fully understand how to make tail recursive functions: they'll be one of the central concepts of larger applications where our main loops will be made that way.</p>

<p>If you want to check your answers, take a look at my implementation of <a class="source" href="static/erlang/recursive.erl">recursive.erl</a>, more precisely the <code>tail_zip/2</code> and <code>tail_lenient_zip/3</code> functions.</p>

<div class="note">
	<p><strong>Note:</strong> tail recursion as seen here is not making the memory grow because when the virtual machine sees a function calling itself in a tail position (the last expression to be evaluated in a function), it eliminates the current stack frame. This is called tail-call optimisation (TCO) and it is a special case of a more general optimisation named <em>Last Call Optimisation</em> (LCO).</p>

	<p>LCO is done whenever the last expression to be evaluated in a function body is another function call. When that happens, as with TCO, the Erlang VM avoids storing the stack frame. As such tail recursion is also possible between multiple functions. As an example, the chain of functions <code>a() -&gt; b().  b() -&gt; c(). c() -&gt; a().</code> will effectively create an infinite loop that won't go out of memory as LCO avoids overflowing the stack. This principle, combined with our use of accumulators is what makes tail recursion useful.</p>
</div>


<h3><a class="section" name="quick-sort">Quick, Sort!</a></h3>

<img class="right explanation" src="static/img/quicksort.png" width="326" height="320" alt="Quicksort expanded: smaller numbers go to the left of the pivot, larger to the right, recursively." />
<p>I can (and will) now assume recursion and tail recursion make sense to you, but just to make sure, I'm going to push for a more complex example, quicksort. Yes, the traditional "hey look I can write short functional code" canonical example. A naive implementation of quicksort works by taking the first element of a list, the <em>pivot</em>, and then putting all the elements smaller or equal to the pivot in a new list, and all those larger in another list. We then take each of these lists and do the same thing on them until each list gets smaller and smaller. This goes on until you have nothing but an empty list to sort, which will be our base case. This implementation is said to be naive because smarter versions of quicksort will try to pick optimal pivots to be faster. We don't really care about that for our example though.</p>

<p>We will need two functions for this one: a first function to partition the list into smaller and larger parts and a second function to apply the partition function on each of the new lists and to glue them together. First of all, we'll write the glue function:</p>

<pre class="brush:erl">
quicksort([]) -&gt; [];
quicksort([Pivot|Rest]) -&gt;
    {Smaller, Larger} = partition(Pivot,Rest,[],[]),
    quicksort(Smaller) ++ [Pivot] ++ quicksort(Larger).
</pre>

<p>This shows the base case, a list already partitioned in larger and smaller parts by another function, the use of a pivot with both lists quicksorted appended before and after it. So this should take care of assembling lists. Now the partitioning function:</p>

<pre class="brush:erl">
partition(_,[], Smaller, Larger) -&gt; {Smaller, Larger};
partition(Pivot, [H|T], Smaller, Larger) -&gt;
    if H =&lt; Pivot -&gt; partition(Pivot, T, [H|Smaller], Larger);
       H &gt;  Pivot -&gt; partition(Pivot, T, Smaller, [H|Larger])
    end. 
</pre>

<p>And you can now run your quicksort function. If you've looked for Erlang examples on the Internet before, you might have seen another implementation of quicksort, one that is simpler and easier to read, but makes use of list comprehensions. The easy to replace parts are the ones that create new lists, the <code>partition/4</code> function:</p>

<pre class="brush:erl">
lc_quicksort([]) -&gt; [];
lc_quicksort([Pivot|Rest]) -&gt;
    lc_quicksort([Smaller || Smaller &lt;- Rest, Smaller =&lt; Pivot])
    ++ [Pivot] ++
    lc_quicksort([Larger || Larger &lt;- Rest, Larger &gt; Pivot]).
</pre>

<p>The main differences are that this version is much easier to read, but in exchange, it has to traverse the list twice to partition it in two parts. This is a fight of clarity against performance, but the real loser here is you, because a function <code>lists:sort/1</code> already exists. Use that one instead.</p>

<div class="note koolaid">
	<p><strong>Don't drink too much Kool-Aid:</strong><br />
       All this conciseness is good for educational purposes, but not for performance. Many functional programming tutorials never mention this! First of all, both implementations here need to process values that are equal to the pivot more than once. We could have decided to instead return 3 lists: elements smaller, larger and equal to the pivot in order to make this more efficient.</p>

    <p>Another problem relates to how we need to traverse all the partitioned lists more than once when attaching them to the pivot. It is possible to reduce the overhead a little by doing the concatenation while partitioning the lists in three parts. If you're curious about this, look at the last function (<code>bestest_qsort/1</code>) of <a class="source" href="static/erlang/recursive.erl">recursive.erl</a> for an example.</p>

    <p>A nice point about all of these quicksorts is that they will work on lists of any data type you've got, even tuples of lists and whatnot. Try them, they work!</p>
</div>

<h3><a class="section" name="more-than-lists">More than lists</a></h3>

<p>By reading this chapter, you might be starting to think recursion in Erlang is mainly a thing concerning lists. While lists are a good example of a data structure that can be defined recursively, there's certainly more than that. For the sake of diversity, we'll see how to build binary trees, and then read data from them.</p>

<img class="left" src="static/img/tree.png" width="167" height="250" alt="An angry tree with an axe" title="How do you like trees now, hippie?" />

<p>First of all, it's important to define what a tree is. In our case, it's nodes all the way down. Nodes are tuples that contain a key, a value associated to the key, and then two other nodes. Of these two nodes, we need one that has a smaller and one that has a larger key than the node holding them. So here's recursion! A tree is a node containing nodes, each of which contains nodes, which in turn also contain nodes. This can't keep going forever (we don't have infinite data to store), so we'll say that our nodes can also contain empty nodes.</p>

<p>To represent nodes, tuples are an appropriate data structure. For our implementation, we can then define these tuples as <code>{node, {Key, Value, Smaller, Larger}}</code> (a tagged tuple!), where <var>Smaller</var> and <var>Larger</var> can be another similar node or an empty node (<code>{node, nil}</code>). We won't actually need a concept more complex than that.</p>

<p>Let's start building a module for our <a class="source" href="static/erlang/tree.erl" title="tree.erl module">very basic tree implementation</a>. The first function, <code>empty/0</code>, returns an empty node. The empty node is the starting point of a new tree, also called the <em>root</em>:</p>

<pre class="brush:erl">
-module(tree).
-export([empty/0, insert/3, lookup/2]).

empty() -&gt; {node, 'nil'}.
</pre>

<p>By using that function and then encapsulating all representations of nodes the same way, we hide the implementation of the tree so people don't need to know how it's built. All that information can be contained by the module alone. If you ever decide to change the representation of a node, you can then do it without breaking external code.</p>

<p>To add content to a tree, we must first understand how to recursively navigate through it. Let's proceed in the same way as we did for every other recursion example by trying to find the base case. Given that an empty tree is an empty node, our base case is thus logically an empty node. So whenever we'll hit an empty node, that's where we can add our new key/value. The rest of the time, our code has to go through the tree trying to find an empty node where to put content.</p>

<p>To find an empty node starting from the root, we must use the fact that the presence of <var>Smaller</var> and <var>Larger</var> nodes let us navigate by comparing the new key we have to insert to the current node's key. If the new key is smaller than the current node's key, we try to find the empty node inside <var>Smaller</var>, and if it's larger, inside <var>Larger</var>. There is one last case, though: what if the new key is equal to the current node's key? We have two options there: let the program fail or replace the value with the new one. This is the option we'll take here. Put into a function all this logic works the following way:</p>

<pre class="brush:erl">
insert(Key, Val, {node, 'nil'}) -&gt;
    {node, {Key, Val, {node, 'nil'}, {node, 'nil'}}};
insert(NewKey, NewVal, {node, {Key, Val, Smaller, Larger}}) when NewKey &lt; Key -&gt;
    {node, {Key, Val, insert(NewKey, NewVal, Smaller), Larger}};
insert(NewKey, NewVal, {node, {Key, Val, Smaller, Larger}}) when NewKey &gt; Key -&gt;
    {node, {Key, Val, Smaller, insert(NewKey, NewVal, Larger)}};
insert(Key, Val, {node, {Key, _, Smaller, Larger}}) -&gt;
    {node, {Key, Val, Smaller, Larger}}.
</pre>

<p>Note here that the function returns a completely new tree. This is typical of functional languages having only single assignment. While this can be seen as inefficient, most of the underlying structures of two versions of a tree sometimes happen to be the same and are thus shared, copied by the VM only when needed.</p>

<p>What's left to do on this example tree implementation is creating a <code>lookup/2</code> function that will let you find a value from a tree by giving its key. The logic needed is extremely similar to the one used to add new content to the tree: we step through the nodes, checking if the lookup key is equal, smaller or larger than the current node's key. We have two base cases: one when the node is empty (the key isn't in the tree) and one when the key is found. Because we don't want our program to crash each time we look for a key that doesn't exist, we'll return the atom <samp>'undefined'</samp>. Otherwise, we'll return <samp>{ok, Value}</samp>. The reason for this is that if we only returned <var>Value</var> and the node contained the atom <samp>'undefined'</samp>, we would have no way to know if the tree did return the right value or failed to find it. By wrapping successful cases in such a tuple, we make it easy to understand which is which. Here's the implemented function:</p>

<pre class="brush:erl">
lookup(_, {node, 'nil'}) -&gt;
    undefined;
lookup(Key, {node, {Key, Val, _, _}}) -&gt;
    {ok, Val};
lookup(Key, {node, {NodeKey, _, Smaller, _}}) when Key &lt; NodeKey -&gt;
    lookup(Key, Smaller);
lookup(Key, {node, {_, _, _, Larger}}) -&gt;
    lookup(Key, Larger).
</pre>

<p>And we're done. Let's test it with by making a little email address book. Compile the file and start the shell: </p>

<pre class="brush:eshell">
1&gt; T1 = tree:insert("Jim Woodland", "jim.woodland@gmail.com", tree:empty()).
{node,{"Jim Woodland","jim.woodland@gmail.com",
       {node,nil},
       {node,nil}}}
2&gt; T2 = tree:insert("Mark Anderson", "i.am.a@hotmail.com", T1).
{node,{"Jim Woodland","jim.woodland@gmail.com",
       {node,nil},
       {node,{"Mark Anderson","i.am.a@hotmail.com",
              {node,nil},
              {node,nil}}}}}
3&gt; Addresses = tree:insert("Anita Bath", "abath@someuni.edu", tree:insert("Kevin Robert", "myfairy@yahoo.com", tree:insert("Wilson Longbrow", "longwil@gmail.com", T2))).
{node,{"Jim Woodland","jim.woodland@gmail.com",
       {node,{"Anita Bath","abath@someuni.edu",
              {node,nil},
              {node,nil}}},
       {node,{"Mark Anderson","i.am.a@hotmail.com",
              {node,{"Kevin Robert","myfairy@yahoo.com",
                     {node,nil},
                     {node,nil}}},
              {node,{"Wilson Longbrow","longwil@gmail.com",
                     {node,nil},
                     {node,nil}}}}}}}
</pre>

<p>And now you can lookup email addresses with it:</p>

<pre class="brush:eshell">
4&gt; tree:lookup("Anita Bath", Addresses).
{ok, "abath@someuni.edu"}
5&gt; tree:lookup("Jacques Requin", Addresses).
undefined
</pre>

<p>That concludes our functional address book example built from a recursive data structure other than a list! <em>Anita Bath</em> now...</p>

<div class="note">
    <p><strong>Note: </strong> Our tree implementation is very naive: we do not support common operations such as deleting nodes or rebalancing the tree to make the following lookups faster. If you're interested in implementing and/or exploring these, studying the implementation of Erlang's <code>gb_trees</code> module (<code>otp_src_R&lt;version&gt;B&lt;revision&gt;/lib/stdlib/src/gb_trees.erl</code>) is a good idea. This is also the module you should use when dealing with trees in your code, rather than reinventing your own wheel.</p>
</div>

<h3><a class="section" name="thinking-recursively">Thinking recursively</a></h3>

<p>If you've understood everything in this chapter, thinking recursively is probably becoming more intuitive. A different aspect of recursive definitions when compared to their imperative counterparts (usually in while or for loops) is that instead of taking a step-by-step approach ("do this, then that, then this, then you're done"), our approach is more declarative ("if you get this input, do that, this otherwise"). This property is made more obvious with the help of pattern matching in function heads.</p>

<p>If you still haven't grasped how recursion works, maybe reading <a class="chapter" href="recursion.html">this</a> will help you.</p>

<p>Joking aside, recursion coupled with pattern matching is sometimes an optimal solution to the problem of writing concise algorithms that are easy to understand. By subdividing each part of a problem into separate functions until they can no longer be simplified, the algorithm becomes nothing but assembling a bunch of correct answers coming from short routines (that's a bit similar to what we did with quicksort). This kind of mental abstraction is also possible with your everyday loops, but I believe the practice is easier with recursion. Your mileage may vary.</p>

<p><strong>And now ladies and gentlemen, a discussion: <em>the author vs. himself</em></strong></p>

<ul class="dialogue">
	<li>&mdash; Okay, I think I understand recursion. I get the declarative aspect of it. I get it has mathematical roots, like with invariable variables. I get that you find it easier in some cases. What else?</li>
	<li>&mdash; It respects a regular pattern. Find the base cases, write them down, then every other cases should try to converge to these base cases to get your answer. It makes writing functions pretty easy.</li>
	<li>&mdash; Yeah, I got that, you repeated it a bunch of times already. My loops can do the same.</li>
	<li>&mdash; Yes they can. Can't deny that!</li>
	<li>&mdash; Right. A thing I don't get is why you bothered writing all these non-tail recursive versions if they're not as good as tail recursive ones.</li>
	<li>&mdash; Oh it's simply to make things easier to grasp. Moving from regular recursion, which is prettier and easier to understand, to tail recursion, which is theoretically more efficient, sounded like a good way to show all options.</li>
	<li>&mdash; Right, so they're useless except for educational purposes, I get it.</li>
	<li>&mdash; Not exactly. In practice you'll see little difference in the performance between tail recursive and normal recursive calls. The areas to take care of are in functions that are supposed to loop infinitely, like main loops. There's also a type of functions that will always generate very large stacks, be slow and possibly crash early if you don't make them tail recursive. The best example of this is the <a class="external" href="http://en.wikipedia.org/wiki/Fibonacci_number" title="Wikipedia entry for the Fibonacci sequence">Fibonacci function</a>, which grows exponentially if it's not iterative or tail recursive. <img class="right explanation" src="static/img/fib.png" width="254" height="144" alt="Function calls expanded to create the sequence '0,1,1,2,3,5,8...'" /> You should profile your code (I'll show how to do that at a later point, I promise), see what slows it down, and fix it.</li>
	<li>&mdash; But loops are always iterative and make this a non-issue.</li>
	<li>&mdash; Yes, but... but... my beautiful Erlang...</li>
	<li>&mdash; Well isn't that great? All that learning because there is no 'while' or 'for' in Erlang. Thank you very much I'm going back to programming my toaster in C!</li>
	<li>&mdash; Not so fast there! Functional programming languages have other assets! If we've found some base case patterns to make our life easier when writing recursive functions, a bunch of smart people have found many more to the point where you will need to write very few recursive functions yourself. If you stay around, I'll show you how such abstractions can be built. But for this we will need more power. Let me tell you about higher order functions...</li>
</ul>
				<ul class="navigation">
											<li><a href="types-or-lack-thereof.html" title="Previous chapter">&lt; Previous</a></li>
										
					<li><a href="contents.html" title="Index">Index</a></li>
					
											<li><a href="higher-order-functions.html" title="Next chapter">Next &gt;</a></li>
									</ul>
			</div><!-- content -->
			<div id="footer">
				<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License Details"><img src="static/img/cc.png" width="88" height="31" alt="Creative Commons Attribution Non-Commercial No Derivative License" /></a>
				<p>Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution Non-Commercial No Derivative License</p>
			</div> <!-- footer -->
		</div> <!-- wrapper -->
		<div id="grass" />
	<script type="text/javascript" src="static/js/shCore.js"></script>
	<script type="text/javascript" src="static/js/shBrushErlang2.js%3F11"></script>
	<script type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.all();
	</script>
	</body>
</html>
