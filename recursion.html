<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="keywords" content="Erlang, function, recursion, tail, loop, stack, iterative, quicksort, factorial, list" />
		<meta name="description" content="Recursion: How to make recursive functions in Erlang, then replace them with tail recursive functions. Examples on how to do it, including a functional version of quicksort." />
        <meta name="google-site-verification" content="mi1UCmFD_2pMLt2jsYHzi_0b6Go9xja8TGllOSoQPVU" />
		<link rel="stylesheet" type="text/css" href="static/css/screen.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shCore.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shThemeLYSE2.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/print.css" media="print" />
		<link href="rss" type="application/rss+xml" rel="alternate" title="LYSE news" />
		<link rel="icon" type="image/png" href="favicon.ico" />
		<link rel="apple-touch-icon" href="static/img/touch-icon-iphone.png" />
		<link rel="apple-touch-icon" sizes="72x72" href="static/img/touch-icon-ipad.png" />
		<link rel="apple-touch-icon" sizes="114x114" href="static/img/touch-icon-iphone4.png" />
		<title>Recursion | Learn You Some Erlang for Great Good!</title>
	</head>
	<body>
		<div id="wrapper">
			<div id="header">
				<h1>Learn you some Erlang</h1>
				<span>for great good!</span>
			</div> <!-- header -->
			<div id="menu">
				<ul>
					<li><a href="content.html" title="Home">Home</a></li>
					<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
					<li><a href="rss" title="Latest News">RSS</a></li>
					<li><a href="static/erlang/learn-you-some-erlang.zip" title="Source Code">Code</a></li>
				</ul>
			</div><!-- menu -->
			<div id="content">
            <div class="noscript"><noscript>Hey there, it appears your Javascript is disabled. That's fine, the site works without it. However, you might prefer reading it with syntax highlighting, which requires Javascript!</noscript></div>
<h2>递归</h2>
<h3><a class="section" name="hello-recursion">你好 递归!</a></h3>

<img class="right" src="static/img/reCURSE.png" width="337" height="182" alt="A car on the road. Dialogue: 'Are we there yet? - No! - Are we there yet? - No! - Are we there yet? - reCURSE YOU KIDS!" title="I apologize for this terrible pun. No great idea could be found to illustrate recursion so you're stuck with this." />

<p> 那些熟悉命令式和面向对象编程语言的读者会想，我们到现在为止为什么还没有介绍循环体。
    对这个问题的回答是“什么是循环？”，在函数类编程语言中通常不提供<code>for</code>和<code>while</code>这种循环控制体。
    取而代之的，函数类编程语言使用<em>递归</em>这一概念。</p>

<p> 我想你还记得在入门那章中是如何介绍不变的变量。
    如果你不记得了，可以再 <a class="chapter" href="starting-out-for-real.html#invariable-variables" title="invariable variables, from Starting out (for real)">回顾</a>一下！
    递归同样可以记住数学概念和函数来解释。
    一个基本的数学函数，如值的阶乘解释递归函数的一个非常好的例子。
    一个数<var>n</var>的阶乘可以产生一个序列 <code>1 x 2 x 3 x ... x <var>n</var></code>，
    或反向的序列<code><var>n</var> x (<var>n</var>-1) x (<var>n</var>-2) x ... x 1</code>。
    我们举一个实例， 3的阶乘是<code>3! = 3 x 2 x 1 = 6</code>。
    4的阶乘将是 <code>4! = 4 x 3 x 2 x 1 = 24</code>。
    这样的函数可以被用下面的数语言来描述：</p>

<img src="static/img/fac.png" alt="n! = { 1 if n = 0 }, { n((n-1)!) if n &gt; 0 }" width="214" height="60" />

<p> 这个告诉我们，如果值<var>n</var>大于<samp>0</samp>时，我们将返回结果<samp>1</samp>。
    如果值大于0，我们将返回<var>n</var>乘以<code>n-1</code>的阶乘，直到n为1为止：
</p>

<pre class="expand">
4! = 4 x 3!
4! = 4 x 3 x 2!
4! = 4 x 3 x 2 x 1!
4! = 4 x 3 x 2 x 1 x 1
</pre>

<p>
    那我们如何将这些数学语言翻译为Erlang？
    这个过程非常简单。
    我们可以看下这些数学符号：
    <code>n!</code>,<samp>1</samp>和<code>n((n-1)!)</code>还有<code>if</code>。
    我们可以得到一个函数名(<code>n!</code>)，哨位(the <code>if</code>)和函数体(<samp>1</samp>和<code>n((n-1)!)</code>)。
    由于语法的限制的原因，我们将<code>n!</code>重命名为<code>fac(N)</code>：</p>

<pre class="brush:erl">
-module(recursive).
-export([fac/1]).

fac(N) when N == 0 -&gt; 1;
fac(N) when N &gt; 0  -&gt; N*fac(N-1).
</pre>

<p> 这个阶乘函数就算完成了！
    这个函数和数学定义非常相似。
    如果我们使用模式匹配，会让我们的函数定义更简单一些：</p>

<pre class="brush:erl">
fac(0) -&gt; 1;
fac(N) when N &gt; 0 -&gt; N*fac(N-1).
</pre>

<p> 所以对那些本身就是递归的数学定义，我们可以很容易且很快的翻译到Erlang中。
    并且我们处在循环中！简单的说递归，我们可以定义为“一个不断调用自己的函数”。
    因为我们无限的循环，我们需要一个终止条件（真正的术语叫<em>基本条件</em>）。
    在这个案例中，终止条件时当<var>n</var>等于<samp>0</samp>。
    此时此刻，我们可以停止调用函数自身且停止执行了。</p>


<h3><a class="section" name="length">Length</a></h3>

<p>Let's try to make it slightly more practical. We'll implement a function to count how many elements a list contains. So we know from the beginning that we will need:</p>
<ul>
    <li>a base case;</li>
    <li>a function that calls itself;</li>
    <li>a list to try our function on.</li>
</ul>

<p>With most recursive functions, I find the base case easier to write first: what's the simplest input we can have to find a length from? Surely an empty list is the simplest one, with a length of 0. So let's make a mental note that <code>[] = 0</code> when dealing with lengths. Then the next simplest list has a length of 1: <code>[_] = 1</code>. This sounds like enough to get going with our definition. We can write this down:</p>

<pre class="brush:erl">
len([]) -&gt; 0;
len([_]) -&gt; 1.
</pre>

<p>Awesome! We can calculate the length of lists, given the length is either 0 or 1! Very useful indeed. Well of course it's useless, because it's not yet recursive, which brings us to the hardest part: extending our function so it calls itself for lists longer than 1 or 0. It was <a class="chapter local" href="starting-out-for-real.html#lists" title="Starting Out (for real): lists">mentioned earlier</a> that lists are defined recursively as <code>[1 | [2| ... [n | []]]]</code>. This means we can use the <code>[H|T]</code> pattern to match against lists of one or more elements, as a list of length one will be defined as <code>[X|[]]</code> and a list of length two will be defined as <code>[X|[Y|[]]]</code>. Note that the second element is a list itself. This means we only need to count the first one and the function can call itself on the second element. Given each value in a list counts as a length of 1, the function can be rewritten the following way:</p>

<pre class="brush:erl">
len([]) -&gt; 0;
len([_|T]) -&gt; 1 + len(T).
</pre>

<p>And now you've got your own recursive function to calculate the length of a list. To see how <code>len/1</code> would behave when ran, let's try it on a given list, say <code>[1,2,3,4]</code>:</p>

<pre class="expand">
len([1,2,3,4]) = len([1 | [2,3,4])
               = 1 + len([2 | [3,4]])
               = 1 + 1 + len([3 | [4]])
               = 1 + 1 + 1 + len([4 | []])
               = 1 + 1 + 1 + 1 + len([])
               = 1 + 1 + 1 + 1 + 0
               = 1 + 1 + 1 + 1
               = 1 + 1 + 2
               = 1 + 3 
               = 4
</pre>

<p>Which is the right answer. Congratulations on your first useful recursive function in Erlang!</p>

<img class="right" src="static/img/tail-recursion.png" width="269" height="135" alt="A childish drawing of a pig with an arrow pointing to the tail mentionning 'tail recursion - Ferd, age 4'" />

<h3><a class="section" name="length-tail-recursion">Length of a Tail Recursion</a></h3>

<p>You might have noticed that for a list of 4 terms, we expanded our function call to a single chain of 5 additions. While this does the job fine for short lists, it can become problematic if your list has a few million values in it. You don't want to keep millions of numbers in memory for such a simple calculation. It's wasteful and there's a better way. Enter <em>tail recursion</em>.</p>

<p>Tail recursion is a way to transform the above linear process (it grows as much as there are elements) to an iterative one (there is not really any growth). To have a function call being tail recursive, it needs to be 'alone'. Let me explain: what made our previous calls grow is how the answer of the first part depended on evaluating the second part. The answer to <code>1 + len(Rest)</code> needs the answer of <code>len(Rest)</code> to be found. The function <code>len(Rest)</code> itself then needed the result of another function call to be found. The additions would get stacked until the last one is found, and only then would the final result be calculated. Tail recursion aims to eliminate this stacking of operation by reducing them as they happen.</p>

<p>In order to achieve this, we will need to hold an extra temporary variable as a parameter in our function. I'll illustrate the concept with the help of the factorial function, but this time defining it to be tail recursive. The aforementioned temporary variable is sometimes called <em>accumulator</em> and acts as a place to store the results of our computations as they happen in order to limit the growth of our calls:</p>

<pre class="brush:erl">
tail_fac(N) -&gt; tail_fac(N,1).

tail_fac(0,Acc) -&gt; Acc;
tail_fac(N,Acc) when N &gt; 0 -&gt; tail_fac(N-1,N*Acc).
</pre>

<p>Here, I define both <code>tail_fac/1</code> and <code>tail_fac/2</code>. The reason for this is that Erlang doesn't allow default arguments in functions (different arity means different function) so we do that manually. In this specific case, <code>tail_fac/1</code> acts like an abstraction over the tail recursive <code>tail_fac/2</code> function. The details about the hidden accumulator of <code>tail_fac/2</code> don't interest anyone, so we would only export <code>tail_fac/1</code> from our module. When running this function, we can expand it to:</p>

<pre class="expand">
tail_fac(4)    = tail_fac(4,1)
tail_fac(4,1)  = tail_fac(4-1, 4*1)
tail_fac(3,4)  = tail_fac(3-1, 3*4)
tail_fac(2,12) = tail_fac(2-1, 2*12)
tail_fac(1,24) = tail_fac(1-1, 1*24)
tail_fac(0,24) = 24
</pre>

<p>See the difference? Now we never need to hold more than two terms in memory: the space usage is constant. It will take as much space to calculate the factorial of 4 as it will take space to calculate the factorial of 1 million (if we forget 4! is a smaller number than 1M! in its complete representation, that is).</p>

<p>With an example of tail recursive factorials under your belt, you might be able to see how this pattern could be applied to our <code>len/1</code> function. What we need is to make our recursive call 'alone'. If you like visual examples, just imagine you're going to put the <code>+1</code> part inside the function call by adding a parameter:</p>

<pre class="brush:erl">
len([]) -&gt; 0;
len([_|T]) -&gt; 1 + len(T).
</pre>

<p>becomes:</p>

<pre class="brush:erl">
tail_len(L) -&gt; tail_len(L,0).

tail_len([], Acc) -&gt; Acc;
tail_len([_|T], Acc) -&gt; tail_len(T,Acc+1).
</pre>

<p>And now your length function is tail recursive.</p>


<h3><a class="section" name="more-recursive-functions">More recursive functions</a></h3>

<img class="left" src="static/img/rock-paper-scissors.png" width="287" height="259" alt="A tiny planet with a rock running after paper running after a pair of scissors which runs after the rock itself." title="I'm stretching the concept too much here." />

<p>We'll write a few more recursive functions, just to get in the habit a bit more. After all, recursion being the only looping construct that exists in Erlang (except list comprehensions), it's one of the most important concepts to understand. It's also useful in every other functional programming language you'll try afterwards, so take notes!</p>

<p>The first function we'll write will be <code>duplicate/2</code>. This function takes an integer as its first parameter and then any other term as its second parameter. It will then create a list of as many copies of the term as specified by the integer. Like before, thinking of the base case first is what might help you get going. For <code>duplicate/2</code>, asking to repeat something 0 time is the most basic thing that can be done. All we have to do is return an empty list, no matter what the term is. Every other case needs to try and get to the base case by calling the function itself. We will also forbid negative values for the integer, because you can't duplicate something <code>-n</code> times:</p>

<pre class="brush:erl">
duplicate(0,_) -&gt;
    [];
duplicate(N,Term) when N &gt; 0 -&gt;
    [Term|duplicate(N-1,Term)].
</pre>

<p>Once the basic recursive function is found, it becomes easier to transform it into a tail recursive one by moving the list construction into a temporary variable:</p>

<pre class="brush:erl">
tail_duplicate(N,Term) -&gt;
    tail_duplicate(N,Term,[]).

tail_duplicate(0,_,List) -&gt;
    List;
tail_duplicate(N,Term,List) when N &gt; 0 -&gt;
    tail_duplicate(N-1, Term, [Term|List]).
</pre>

<p>Success! I want to change the subject a little bit here by drawing a parallel between tail recursion and a while loop. Our <code>tail_duplicate/2</code> function has all the usual parts of a while loop. If we were to imagine a while loop in a fictional language with Erlang-like syntax, our function could look a bit like this:</p>

<pre class="brush:erl">
function(N, Term) -&gt;
    while N &gt; 0 -&gt;
        List = [Term|List],
        N = N-1
    end,
    List.
</pre>

<p>Note that all the elements are there in both the fictional language and in Erlang. Only their position changes. This demonstrates that a proper tail recursive function is similar to an iterative process, like a while loop.</p>

<p>There's also an interesting property that we can 'discover' when we compare recursive and tail recursive functions by writing a <code>reverse/1</code> function, which will reverse a list of terms. For such a function, the base case is an empty list, for which we have nothing to reverse. We can just return an empty list when that happens. Every other possibility should try to converge to the base case by calling itself, like with <code>duplicate/2</code>. Our function is going to iterate through the list by pattern matching <code>[H|T]</code> and then putting <var>H</var> after the rest of the list:</p>

<pre class="brush:erl">
reverse([]) -&gt; [];
reverse([H|T]) -&gt; reverse(T)++[H].
</pre>

<p>On long lists, this will be a true nightmare: not only will we stack up all our append operations, but we will need to traverse the whole list for every single of these appends until the last one! For visual readers, the many checks can be represented as:</p>

<pre class="expand">
reverse([1,2,3,4]) = [4]++[3]++[2]++[1]
                      &#8593;    &#8629;
                   = [4,3]++[2]++[1]
                      &#8593; &#8593;    &#8629;
                   = [4,3,2]++[1]
                      &#8593; &#8593; &#8593;    &#8629;
                   = [4,3,2,1]
</pre>

<p>This is where tail recursion comes to the rescue. Because we will use an accumulator and will add a new head to it every time, our list will automatically be reversed. Let's first see the implementation:</p>

<pre class="brush:erl">
tail_reverse(L) -&gt; tail_reverse(L,[]).

tail_reverse([],Acc) -&gt; Acc;
tail_reverse([H|T],Acc) -&gt; tail_reverse(T, [H|Acc]).
</pre>

<p>If we represent this one in a similar manner as the normal version, we get:</p>

<pre class="expand">
tail_reverse([1,2,3,4]) = tail_reverse([2,3,4], [1])
                        = tail_reverse([3,4], [2,1])
                        = tail_reverse([4], [3,2,1])
                        = tail_reverse([], [4,3,2,1])
                        = [4,3,2,1]   
</pre>

<p>Which shows that the number of elements visited to reverse our list is now linear: not only do we avoid growing the stack, we also do our operations in a much more efficient manner!</p>

<p>Another function to implement could be <code>sublist/2</code>, which takes a list <var>L</var> and an integer <var>N</var>, and returns the <var>N</var> first elements of the list. As an example, <code>sublist([1,2,3,4,5,6],3)</code> would return <samp>[1,2,3]</samp>. Again, the base case is trying to obtain 0 elements from a list. Take care however, because <code>sublist/2</code> is a bit different. You've got a second base case when the list passed is empty! If we do not check for empty lists, an error would be thrown when calling <code>recursive:sublist([1],2).</code> while we want <code>[1]</code> instead. Once this is defined, the recursive part of the function only has to cycle through the list, keeping elements as it goes, until it hits one of the base cases:</p>

<pre class="brush:erl">
sublist(_,0) -&gt; [];
sublist([],_) -&gt; [];
sublist([H|T],N) when N &gt; 0 -&gt; [H|sublist(T,N-1)].
</pre>

<p>Which can then be transformed to a tail recursive form in the same manner as before:</p>

<pre class="brush:erl">
tail_sublist(L, N) -&gt; tail_sublist(L, N, []).

tail_sublist(_, 0, SubList) -&gt; SubList;
tail_sublist([], _, SubList) -&gt; SubList;
tail_sublist([H|T], N, SubList) when N &gt; 0 -&gt;
    tail_sublist(T, N-1, [H|SubList]).
</pre>

<p>There's a flaw in this function. <em>A fatal flaw!</em> We use a list as an accumulator in exactly the same manner we did to reverse our list. If you compile this function as is, <code>sublist([1,2,3,4,5,6],3)</code> would not return <samp>[1,2,3]</samp>, but <samp>[3,2,1]</samp>. The only thing we can do is take the final result and reverse it ourselves. Just change the <code>tail_sublist/2</code> call and leave all our recursive logic intact:</p>

<pre class="brush:erl">
tail_sublist(L, N) -&gt; reverse(tail_sublist(L, N, [])).
</pre>

<p>The final result will be ordered correctly. It might seem like reversing our list after a tail recursive call is a waste of time and you would be partially right (we still save memory doing this). On shorter lists, you might find your code is running faster with normal recursive calls than with tail recursive calls for this reason, but as your data sets grow, reversing the list will be comparatively lighter.</p>

<div class="note">
    <p><strong>Note:</strong> instead of writing your own <code>reverse/1</code> function, you should use <code>lists:reverse/1</code>. It's been used so much for tail recursive calls that the maintainers and developers of Erlang decided to turn it into a BIF. Your lists can now benefit from extremely fast reversal (thanks to functions written in C) which will make the reversal disadvantage a lot less obvious. The rest of the code in this chapter will make use of our own reversal function, but after that you should not use it ever again.</p>
</div>

<p>To push things a bit further, we'll write a zipping function. A zipping function will take two lists of same length as parameters and will join them as a list of tuples which all hold two terms. Our own <code>zip/2</code> function will behave this way:</p>

<pre class="brush:eshell">
1&gt; recursive:zip([a,b,c],[1,2,3]).
[{a,1},{b,2},{c,3}]
</pre>

<p>Given we want our parameters to both have the same length, the base case will be zipping two empty lists:</p>

<pre class="brush:erl">
zip([],[]) -&gt; [];
zip([X|Xs],[Y|Ys]) -&gt; [{X,Y}|zip(Xs,Ys)].
</pre>

<p>However, if you wanted a more lenient zip function, you could decide to have it finish whenever one of the two list is done. In this scenario, you therefore have two base cases:</p>

<pre class="brush:erl">
lenient_zip([],_) -&gt; [];
lenient_zip(_,[]) -&gt; [];
lenient_zip([X|Xs],[Y|Ys]) -&gt; [{X,Y}|lenient_zip(Xs,Ys)].
</pre>


<p>Notice that no matter what our base cases are, the recursive part of the function remains the same. I would suggest you try and make your own tail recursive versions of <code>zip/2</code> and <code>lenient_zip/2</code>, just to make sure you fully understand how to make tail recursive functions: they'll be one of the central concepts of larger applications where our main loops will be made that way.</p>

<p>If you want to check your answers, take a look at my implementation of <a class="source" href="static/erlang/recursive.erl">recursive.erl</a>, more precisely the <code>tail_zip/2</code> and <code>tail_lenient_zip/3</code> functions.</p>

<div class="note">
	<p><strong>Note:</strong> tail recursion as seen here is not making the memory grow because when the virtual machine sees a function calling itself in a tail position (the last expression to be evaluated in a function), it eliminates the current stack frame. This is called tail-call optimisation (TCO) and it is a special case of a more general optimisation named <em>Last Call Optimisation</em> (LCO).</p>

	<p>LCO is done whenever the last expression to be evaluated in a function body is another function call. When that happens, as with TCO, the Erlang VM avoids storing the stack frame. As such tail recursion is also possible between multiple functions. As an example, the chain of functions <code>a() -&gt; b().  b() -&gt; c(). c() -&gt; a().</code> will effectively create an infinite loop that won't go out of memory as LCO avoids overflowing the stack. This principle, combined with our use of accumulators is what makes tail recursion useful.</p>
</div>


<h3><a class="section" name="quick-sort">Quick, Sort!</a></h3>

<img class="right explanation" src="static/img/quicksort.png" width="326" height="320" alt="Quicksort expanded: smaller numbers go to the left of the pivot, larger to the right, recursively." />
<p>I can (and will) now assume recursion and tail recursion make sense to you, but just to make sure, I'm going to push for a more complex example, quicksort. Yes, the traditional "hey look I can write short functional code" canonical example. A naive implementation of quicksort works by taking the first element of a list, the <em>pivot</em>, and then putting all the elements smaller or equal to the pivot in a new list, and all those larger in another list. We then take each of these lists and do the same thing on them until each list gets smaller and smaller. This goes on until you have nothing but an empty list to sort, which will be our base case. This implementation is said to be naive because smarter versions of quicksort will try to pick optimal pivots to be faster. We don't really care about that for our example though.</p>

<p>We will need two functions for this one: a first function to partition the list into smaller and larger parts and a second function to apply the partition function on each of the new lists and to glue them together. First of all, we'll write the glue function:</p>

<pre class="brush:erl">
quicksort([]) -&gt; [];
quicksort([Pivot|Rest]) -&gt;
    {Smaller, Larger} = partition(Pivot,Rest,[],[]),
    quicksort(Smaller) ++ [Pivot] ++ quicksort(Larger).
</pre>

<p>This shows the base case, a list already partitioned in larger and smaller parts by another function, the use of a pivot with both lists quicksorted appended before and after it. So this should take care of assembling lists. Now the partitioning function:</p>

<pre class="brush:erl">
partition(_,[], Smaller, Larger) -&gt; {Smaller, Larger};
partition(Pivot, [H|T], Smaller, Larger) -&gt;
    if H =&lt; Pivot -&gt; partition(Pivot, T, [H|Smaller], Larger);
       H &gt;  Pivot -&gt; partition(Pivot, T, Smaller, [H|Larger])
    end. 
</pre>

<p>And you can now run your quicksort function. If you've looked for Erlang examples on the Internet before, you might have seen another implementation of quicksort, one that is simpler and easier to read, but makes use of list comprehensions. The easy to replace parts are the ones that create new lists, the <code>partition/4</code> function:</p>

<pre class="brush:erl">
lc_quicksort([]) -&gt; [];
lc_quicksort([Pivot|Rest]) -&gt;
    lc_quicksort([Smaller || Smaller &lt;- Rest, Smaller =&lt; Pivot])
    ++ [Pivot] ++
    lc_quicksort([Larger || Larger &lt;- Rest, Larger &gt; Pivot]).
</pre>

<p>The main differences are that this version is much easier to read, but in exchange, it has to traverse the list twice to partition it in two parts. This is a fight of clarity against performance, but the real loser here is you, because a function <code>lists:sort/1</code> already exists. Use that one instead.</p>

<div class="note koolaid">
	<p><strong>Don't drink too much Kool-Aid:</strong><br />
       All this conciseness is good for educational purposes, but not for performance. Many functional programming tutorials never mention this! First of all, both implementations here need to process values that are equal to the pivot more than once. We could have decided to instead return 3 lists: elements smaller, larger and equal to the pivot in order to make this more efficient.</p>

    <p>Another problem relates to how we need to traverse all the partitioned lists more than once when attaching them to the pivot. It is possible to reduce the overhead a little by doing the concatenation while partitioning the lists in three parts. If you're curious about this, look at the last function (<code>bestest_qsort/1</code>) of <a class="source" href="static/erlang/recursive.erl">recursive.erl</a> for an example.</p>

    <p>A nice point about all of these quicksorts is that they will work on lists of any data type you've got, even tuples of lists and whatnot. Try them, they work!</p>
</div>

<h3><a class="section" name="more-than-lists">More than lists</a></h3>

<p>By reading this chapter, you might be starting to think recursion in Erlang is mainly a thing concerning lists. While lists are a good example of a data structure that can be defined recursively, there's certainly more than that. For the sake of diversity, we'll see how to build binary trees, and then read data from them.</p>

<img class="left" src="static/img/tree.png" width="167" height="250" alt="An angry tree with an axe" title="How do you like trees now, hippie?" />

<p>First of all, it's important to define what a tree is. In our case, it's nodes all the way down. Nodes are tuples that contain a key, a value associated to the key, and then two other nodes. Of these two nodes, we need one that has a smaller and one that has a larger key than the node holding them. So here's recursion! A tree is a node containing nodes, each of which contains nodes, which in turn also contain nodes. This can't keep going forever (we don't have infinite data to store), so we'll say that our nodes can also contain empty nodes.</p>

<p>To represent nodes, tuples are an appropriate data structure. For our implementation, we can then define these tuples as <code>{node, {Key, Value, Smaller, Larger}}</code> (a tagged tuple!), where <var>Smaller</var> and <var>Larger</var> can be another similar node or an empty node (<code>{node, nil}</code>). We won't actually need a concept more complex than that.</p>

<p>Let's start building a module for our <a class="source" href="static/erlang/tree.erl" title="tree.erl module">very basic tree implementation</a>. The first function, <code>empty/0</code>, returns an empty node. The empty node is the starting point of a new tree, also called the <em>root</em>:</p>

<pre class="brush:erl">
-module(tree).
-export([empty/0, insert/3, lookup/2]).

empty() -&gt; {node, 'nil'}.
</pre>

<p>By using that function and then encapsulating all representations of nodes the same way, we hide the implementation of the tree so people don't need to know how it's built. All that information can be contained by the module alone. If you ever decide to change the representation of a node, you can then do it without breaking external code.</p>

<p>To add content to a tree, we must first understand how to recursively navigate through it. Let's proceed in the same way as we did for every other recursion example by trying to find the base case. Given that an empty tree is an empty node, our base case is thus logically an empty node. So whenever we'll hit an empty node, that's where we can add our new key/value. The rest of the time, our code has to go through the tree trying to find an empty node where to put content.</p>

<p>To find an empty node starting from the root, we must use the fact that the presence of <var>Smaller</var> and <var>Larger</var> nodes let us navigate by comparing the new key we have to insert to the current node's key. If the new key is smaller than the current node's key, we try to find the empty node inside <var>Smaller</var>, and if it's larger, inside <var>Larger</var>. There is one last case, though: what if the new key is equal to the current node's key? We have two options there: let the program fail or replace the value with the new one. This is the option we'll take here. Put into a function all this logic works the following way:</p>

<pre class="brush:erl">
insert(Key, Val, {node, 'nil'}) -&gt;
    {node, {Key, Val, {node, 'nil'}, {node, 'nil'}}};
insert(NewKey, NewVal, {node, {Key, Val, Smaller, Larger}}) when NewKey &lt; Key -&gt;
    {node, {Key, Val, insert(NewKey, NewVal, Smaller), Larger}};
insert(NewKey, NewVal, {node, {Key, Val, Smaller, Larger}}) when NewKey &gt; Key -&gt;
    {node, {Key, Val, Smaller, insert(NewKey, NewVal, Larger)}};
insert(Key, Val, {node, {Key, _, Smaller, Larger}}) -&gt;
    {node, {Key, Val, Smaller, Larger}}.
</pre>

<p>Note here that the function returns a completely new tree. This is typical of functional languages having only single assignment. While this can be seen as inefficient, most of the underlying structures of two versions of a tree sometimes happen to be the same and are thus shared, copied by the VM only when needed.</p>

<p>What's left to do on this example tree implementation is creating a <code>lookup/2</code> function that will let you find a value from a tree by giving its key. The logic needed is extremely similar to the one used to add new content to the tree: we step through the nodes, checking if the lookup key is equal, smaller or larger than the current node's key. We have two base cases: one when the node is empty (the key isn't in the tree) and one when the key is found. Because we don't want our program to crash each time we look for a key that doesn't exist, we'll return the atom <samp>'undefined'</samp>. Otherwise, we'll return <samp>{ok, Value}</samp>. The reason for this is that if we only returned <var>Value</var> and the node contained the atom <samp>'undefined'</samp>, we would have no way to know if the tree did return the right value or failed to find it. By wrapping successful cases in such a tuple, we make it easy to understand which is which. Here's the implemented function:</p>

<pre class="brush:erl">
lookup(_, {node, 'nil'}) -&gt;
    undefined;
lookup(Key, {node, {Key, Val, _, _}}) -&gt;
    {ok, Val};
lookup(Key, {node, {NodeKey, _, Smaller, _}}) when Key &lt; NodeKey -&gt;
    lookup(Key, Smaller);
lookup(Key, {node, {_, _, _, Larger}}) -&gt;
    lookup(Key, Larger).
</pre>

<p>And we're done. Let's test it with by making a little email address book. Compile the file and start the shell: </p>

<pre class="brush:eshell">
1&gt; T1 = tree:insert("Jim Woodland", "jim.woodland@gmail.com", tree:empty()).
{node,{"Jim Woodland","jim.woodland@gmail.com",
       {node,nil},
       {node,nil}}}
2&gt; T2 = tree:insert("Mark Anderson", "i.am.a@hotmail.com", T1).
{node,{"Jim Woodland","jim.woodland@gmail.com",
       {node,nil},
       {node,{"Mark Anderson","i.am.a@hotmail.com",
              {node,nil},
              {node,nil}}}}}
3&gt; Addresses = tree:insert("Anita Bath", "abath@someuni.edu", tree:insert("Kevin Robert", "myfairy@yahoo.com", tree:insert("Wilson Longbrow", "longwil@gmail.com", T2))).
{node,{"Jim Woodland","jim.woodland@gmail.com",
       {node,{"Anita Bath","abath@someuni.edu",
              {node,nil},
              {node,nil}}},
       {node,{"Mark Anderson","i.am.a@hotmail.com",
              {node,{"Kevin Robert","myfairy@yahoo.com",
                     {node,nil},
                     {node,nil}}},
              {node,{"Wilson Longbrow","longwil@gmail.com",
                     {node,nil},
                     {node,nil}}}}}}}
</pre>

<p>And now you can lookup email addresses with it:</p>

<pre class="brush:eshell">
4&gt; tree:lookup("Anita Bath", Addresses).
{ok, "abath@someuni.edu"}
5&gt; tree:lookup("Jacques Requin", Addresses).
undefined
</pre>

<p>That concludes our functional address book example built from a recursive data structure other than a list! <em>Anita Bath</em> now...</p>

<div class="note">
    <p><strong>Note: </strong> Our tree implementation is very naive: we do not support common operations such as deleting nodes or rebalancing the tree to make the following lookups faster. If you're interested in implementing and/or exploring these, studying the implementation of Erlang's <code>gb_trees</code> module (<code>otp_src_R&lt;version&gt;B&lt;revision&gt;/lib/stdlib/src/gb_trees.erl</code>) is a good idea. This is also the module you should use when dealing with trees in your code, rather than reinventing your own wheel.</p>
</div>

<h3><a class="section" name="thinking-recursively">Thinking recursively</a></h3>

<p>If you've understood everything in this chapter, thinking recursively is probably becoming more intuitive. A different aspect of recursive definitions when compared to their imperative counterparts (usually in while or for loops) is that instead of taking a step-by-step approach ("do this, then that, then this, then you're done"), our approach is more declarative ("if you get this input, do that, this otherwise"). This property is made more obvious with the help of pattern matching in function heads.</p>

<p>If you still haven't grasped how recursion works, maybe reading <a class="chapter" href="recursion.html">this</a> will help you.</p>

<p>Joking aside, recursion coupled with pattern matching is sometimes an optimal solution to the problem of writing concise algorithms that are easy to understand. By subdividing each part of a problem into separate functions until they can no longer be simplified, the algorithm becomes nothing but assembling a bunch of correct answers coming from short routines (that's a bit similar to what we did with quicksort). This kind of mental abstraction is also possible with your everyday loops, but I believe the practice is easier with recursion. Your mileage may vary.</p>

<p><strong>And now ladies and gentlemen, a discussion: <em>the author vs. himself</em></strong></p>

<ul class="dialogue">
	<li>&mdash; Okay, I think I understand recursion. I get the declarative aspect of it. I get it has mathematical roots, like with invariable variables. I get that you find it easier in some cases. What else?</li>
	<li>&mdash; It respects a regular pattern. Find the base cases, write them down, then every other cases should try to converge to these base cases to get your answer. It makes writing functions pretty easy.</li>
	<li>&mdash; Yeah, I got that, you repeated it a bunch of times already. My loops can do the same.</li>
	<li>&mdash; Yes they can. Can't deny that!</li>
	<li>&mdash; Right. A thing I don't get is why you bothered writing all these non-tail recursive versions if they're not as good as tail recursive ones.</li>
	<li>&mdash; Oh it's simply to make things easier to grasp. Moving from regular recursion, which is prettier and easier to understand, to tail recursion, which is theoretically more efficient, sounded like a good way to show all options.</li>
	<li>&mdash; Right, so they're useless except for educational purposes, I get it.</li>
	<li>&mdash; Not exactly. In practice you'll see little difference in the performance between tail recursive and normal recursive calls. The areas to take care of are in functions that are supposed to loop infinitely, like main loops. There's also a type of functions that will always generate very large stacks, be slow and possibly crash early if you don't make them tail recursive. The best example of this is the <a class="external" href="http://en.wikipedia.org/wiki/Fibonacci_number" title="Wikipedia entry for the Fibonacci sequence">Fibonacci function</a>, which grows exponentially if it's not iterative or tail recursive. <img class="right explanation" src="static/img/fib.png" width="254" height="144" alt="Function calls expanded to create the sequence '0,1,1,2,3,5,8...'" /> You should profile your code (I'll show how to do that at a later point, I promise), see what slows it down, and fix it.</li>
	<li>&mdash; But loops are always iterative and make this a non-issue.</li>
	<li>&mdash; Yes, but... but... my beautiful Erlang...</li>
	<li>&mdash; Well isn't that great? All that learning because there is no 'while' or 'for' in Erlang. Thank you very much I'm going back to programming my toaster in C!</li>
	<li>&mdash; Not so fast there! Functional programming languages have other assets! If we've found some base case patterns to make our life easier when writing recursive functions, a bunch of smart people have found many more to the point where you will need to write very few recursive functions yourself. If you stay around, I'll show you how such abstractions can be built. But for this we will need more power. Let me tell you about higher order functions...</li>
</ul>
				<ul class="navigation">
											<li><a href="types-or-lack-thereof.html" title="Previous chapter">&lt; Previous</a></li>
										
					<li><a href="contents.html" title="Index">Index</a></li>
					
											<li><a href="higher-order-functions.html" title="Next chapter">Next &gt;</a></li>
									</ul>
			</div><!-- content -->
			<div id="footer">
				<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License Details"><img src="static/img/cc.png" width="88" height="31" alt="Creative Commons Attribution Non-Commercial No Derivative License" /></a>
				<p>Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution Non-Commercial No Derivative License</p>
			</div> <!-- footer -->
		</div> <!-- wrapper -->
		<div id="grass" />
	<script type="text/javascript" src="static/js/shCore.js"></script>
	<script type="text/javascript" src="static/js/shBrushErlang2.js%3F11"></script>
	<script type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.all();
	</script>
	</body>
</html>
